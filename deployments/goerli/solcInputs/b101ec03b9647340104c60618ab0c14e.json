{
  "language": "Solidity",
  "sources": {
    "@boringcrypto/boring-solidity/contracts/BoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable no-inline-assembly\r\n\r\n// WARNING!!!\r\n// Combining BoringBatchable with msg.value can cause double spending issues\r\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\r\n\r\nimport \"./interfaces/IERC20.sol\";\r\n\r\ncontract BaseBoringBatchable {\r\n    error BatchError(bytes innerError);\r\n\r\n    /// @dev Helper function to extract a useful revert message from a failed call.\r\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\r\n    function _getRevertMsg(bytes memory _returnData) internal pure{\r\n        // If the _res length is less than 68, then\r\n        // the transaction failed with custom error or silently (without a revert message)\r\n        if (_returnData.length < 68) revert BatchError(_returnData);\r\n\r\n        assembly {\r\n            // Slice the sighash.\r\n            _returnData := add(_returnData, 0x04)\r\n        }\r\n        revert(abi.decode(_returnData, (string))); // All that remains is the revert string\r\n    }\r\n\r\n    /// @notice Allows batched call to self (this contract).\r\n    /// @param calls An array of inputs for each call.\r\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\r\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\r\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\r\n    // C3: The length of the loop is fully under user control, so can't be exploited\r\n    // C7: Delegatecall is only used on the same contract, so it's safe\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            if (!success && revertOnFail) {\r\n                _getRevertMsg(result);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract BoringBatchable is BaseBoringBatchable {\r\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\r\n    /// Lookup `IERC20.permit`.\r\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\r\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\r\n    function permitToken(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public {\r\n        token.permit(from, to, amount, deadline, v, r, s);\r\n    }\r\n}\r\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./interfaces/IMasterContract.sol\";\n\n// solhint-disable no-inline-assembly\n\ncontract BoringFactory {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n\n    /// @notice Mapping from clone contracts to their masterContract.\n    mapping(address => address) public masterContractOf;\n\n    /// @notice Mapping from masterContract to an array of all clones\n    /// On mainnet events can be used to get this list, but events aren't always easy to retrieve and\n    /// barely work on sidechains. While this adds gas, it makes enumerating all clones much easier.\n    mapping(address => address[]) public clonesOf;\n\n    /// @notice Returns the count of clones that exists for a specific masterContract\n    /// @param masterContract The address of the master contract.\n    /// @return cloneCount total number of clones for the masterContract.\n    function clonesOfCount(address masterContract) public view returns (uint256 cloneCount) {\n        cloneCount = clonesOf[masterContract].length;\n    }\n\n    /// @notice Deploys a given master Contract as a clone.\n    /// Any ETH transferred with this call is forwarded to the new clone.\n    /// Emits `LogDeploy`.\n    /// @param masterContract The address of the contract to clone.\n    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.\n    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.\n    /// @return cloneAddress Address of the created clone contract.\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) public payable returns (address cloneAddress) {\n        require(masterContract != address(0), \"BoringFactory: No masterContract\");\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\n\n        if (useCreate2) {\n            // each masterContract has different code already. So clones are distinguished by their data only.\n            bytes32 salt = keccak256(data);\n\n            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create2(0, clone, 0x37, salt)\n            }\n        } else {\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create(0, clone, 0x37)\n            }\n        }\n        masterContractOf[cloneAddress] = masterContract;\n        clonesOf[masterContract].push(cloneAddress);\n\n        IMasterContract(cloneAddress).init{value: msg.value}(data);\n\n        emit LogDeploy(masterContract, data, cloneAddress);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Simplified by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\n    }\n\n    constructor() {\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = block.chainid);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) internal {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n        emit Transfer(address(0), user, amount);\n    }\n\n    function _burn(address user, uint256 amount) internal {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n        emit Transfer(user, address(0), amount);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IERC165.sol\";\n\ninterface IERC1155 is IERC165 {\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\n    // By removing them you can't accidentally use them.\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStrictERC20 {\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is ERC165 */ {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata /* is ERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable /* is ERC721 */ {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    ///  `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n// solhint-disable no-empty-blocks\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n                case 1 {\n                    mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n                }\n                case 2 {\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\n                }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n\nlibrary BoringAddress {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendNative(address to, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"BoringAddress: transfer failed\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @return totalSupply The token totalSupply.\n    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));\n        require(success && data.length >= 32, \"BoringERC20: totalSupply failed\");\n        totalSupply = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\n                base++;\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\n                elastic++;\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic += uint128(elastic);\n        total.base += uint128(base);\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic -= uint128(elastic);\n        total.base -= uint128(base);\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic += uint128(elastic);\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic -= uint128(elastic);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/BeachBar.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\n\r\nimport '../yieldbox/contracts/YieldBox.sol';\r\nimport './singularity/interfaces/ISingularity.sol';\r\nimport './IBeachBar.sol';\r\n\r\n// TODO: Permissionless market deployment\r\n///     + asset registration? (toggle to renounce ownership so users can call)\r\n/// @title Global market registry\r\n/// @notice Singularity management\r\ncontract BeachBar is BoringOwnable {\r\n    /// @notice returns the YieldBox contract\r\n    YieldBox public immutable yieldBox;\r\n\r\n    /// @notice returns the TAP contract\r\n    IERC20 public immutable tapToken;\r\n    /// @notice returns TAP asset id registered in the YieldBox contract\r\n    uint256 public immutable tapAssetId;\r\n\r\n    /// @notice returns USD0 contract\r\n    IUSD0 public usdoToken;\r\n\r\n    /// @notice returns USD0 asset id registered in the YieldBox contract\r\n    uint256 public usdoAssetId;\r\n\r\n    /// @notice master contracts registered\r\n    IBeachBar.MasterContract[] public masterContracts;\r\n\r\n    // Used to check if a master contract is registered to be used as a Singularity template\r\n    mapping(address => bool) isMasterContractRegistered;\r\n\r\n    /// @notice protocol fees\r\n    address public feeTo;\r\n\r\n    /// @notice TAP distributor fees\r\n    address public feeVeTap;\r\n\r\n    /// @notice whitelisted swappers\r\n    mapping(IMultiSwapper => bool) public swappers;\r\n\r\n    /// @notice creates a BeachBar contract\r\n    /// @param _yieldBox YieldBox contract address\r\n    /// @param tapToken_ TapOFT contract address\r\n    constructor(YieldBox _yieldBox, IERC20 tapToken_) {\r\n        yieldBox = _yieldBox;\r\n        tapToken = tapToken_;\r\n        tapAssetId = uint96(\r\n            _yieldBox.registerAsset(\r\n                TokenType.ERC20,\r\n                address(tapToken_),\r\n                IStrategy(address(0)),\r\n                0\r\n            )\r\n        );\r\n    }\r\n\r\n    // **************//\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n\r\n    event ProtocolWithdrawal(address[] markets, uint256 timestamp);\r\n    event RegisterMasterContract(address location, IBeachBar.ContractType risk);\r\n    event RegisterSingularity(address location, address masterContract);\r\n    event FeeToUpdate(address newFeeTo);\r\n    event FeeVeTapUpdate(address newFeeVeTap);\r\n    event SwapperUpdate(address swapper, bool isRegistered);\r\n    event UsdoTokenUpdated(address indexed usdoToken, uint256 assetId);\r\n\r\n    // ******************//\r\n    // *** MODIFIERS *** //\r\n    // ***************** //\r\n    modifier registeredMasterContract(address mc) {\r\n        require(\r\n            isMasterContractRegistered[mc] == true,\r\n            'BeachBar: MC not registered'\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n\r\n    /// @notice Get all the Singularity contract addresses\r\n    /// @return markets list of available markets\r\n    function tapiocaMarkets() public view returns (address[] memory markets) {\r\n        uint256 _masterContractLength = masterContracts.length;\r\n        uint256 marketsLength = 0;\r\n\r\n        unchecked {\r\n            // We first compute the length of the markets array\r\n            for (uint256 i = 0; i < _masterContractLength; ) {\r\n                marketsLength += yieldBox.clonesOfCount(\r\n                    masterContracts[i].location\r\n                );\r\n\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        markets = new address[](marketsLength);\r\n\r\n        uint256 marketIndex;\r\n        uint256 clonesOfLength;\r\n\r\n        unchecked {\r\n            // We populate the array\r\n            for (uint256 i = 0; i < _masterContractLength; ) {\r\n                address mcLocation = masterContracts[i].location;\r\n                clonesOfLength = yieldBox.clonesOfCount(mcLocation);\r\n\r\n                // Loop through clones of the current MC.\r\n                for (uint256 j = 0; j < clonesOfLength; ) {\r\n                    markets[marketIndex] = yieldBox.clonesOf(mcLocation, j);\r\n                    ++marketIndex;\r\n                    ++j;\r\n                }\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Get the length of `masterContracts`\r\n    function masterContractLength() public view returns (uint256) {\r\n        return masterContracts.length;\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n\r\n    /// @notice Loop through the master contracts and call `depositFeesToYieldBox()` to each one of their clones.\r\n    /// @dev `swappers_` can have one element that'll be used for all clones. Or one swapper per MasterContract.\r\n    /// @dev Fees are withdrawn in TAP and sent to the FeeDistributor contract\r\n    /// @param swappers_ One or more swappers to convert the asset to TAP.\r\n    function withdrawAllProtocolFees(\r\n        IMultiSwapper[] calldata swappers_,\r\n        IBeachBar.SwapData[] calldata swapData_\r\n    ) public {\r\n        require(address(swappers_[0]) != address(0), 'BeachBar: zero address');\r\n\r\n        uint256 _masterContractLength = masterContracts.length;\r\n        bool singleSwapper = swappers_.length != _masterContractLength;\r\n\r\n        address[] memory markets = tapiocaMarkets();\r\n        uint256 length = markets.length;\r\n\r\n        unchecked {\r\n            for (uint256 i = 0; i < length; ) {\r\n                ISingularity(markets[i]).depositFeesToYieldBox(\r\n                    singleSwapper ? swappers_[0] : swappers_[i],\r\n                    singleSwapper ? swapData_[0] : swapData_[i]\r\n                );\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        emit ProtocolWithdrawal(markets, block.timestamp);\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n\r\n    /// @notice Used to set the USD0 token\r\n    /// @dev sets usdoToken and usdoAssetId\r\n    /// @param _usdoToken the USD0 token address\r\n    function setUsdoToken(address _usdoToken) external onlyOwner {\r\n        usdoToken = IUSD0(_usdoToken);\r\n        usdoAssetId = uint96(\r\n            yieldBox.registerAsset(\r\n                TokenType.ERC20,\r\n                _usdoToken,\r\n                IStrategy(address(0)),\r\n                0\r\n            )\r\n        );\r\n        emit UsdoTokenUpdated(_usdoToken, usdoAssetId);\r\n    }\r\n\r\n    /// @notice Register a master contract\r\n    /// @param mcAddress The address of the contract\r\n    /// @param contractType_ The risk type of the contract\r\n    function registerMasterContract(\r\n        address mcAddress,\r\n        IBeachBar.ContractType contractType_\r\n    ) external onlyOwner {\r\n        require(\r\n            isMasterContractRegistered[mcAddress] == false,\r\n            'BeachBar: MC registered'\r\n        );\r\n\r\n        IBeachBar.MasterContract memory mc;\r\n        mc.location = mcAddress;\r\n        mc.risk = contractType_;\r\n        masterContracts.push(mc);\r\n        isMasterContractRegistered[mcAddress] = true;\r\n\r\n        emit RegisterMasterContract(mcAddress, contractType_);\r\n    }\r\n\r\n    /// @notice Registera a Singularity\r\n    /// @param mc The address of the master contract which must be already registered\r\n    /// @param data The init data of the Singularity\r\n    /// @param useCreate2 Whether to use create2 or not\r\n    function registerSingularity(\r\n        address mc,\r\n        bytes calldata data,\r\n        bool useCreate2\r\n    )\r\n        external\r\n        payable\r\n        onlyOwner\r\n        registeredMasterContract(mc)\r\n        returns (address _contract)\r\n    {\r\n        _contract = yieldBox.deploy(mc, data, useCreate2);\r\n        emit RegisterSingularity(_contract, mc);\r\n    }\r\n\r\n    /// @notice Execute an only owner function inside of a Singularity market\r\n    function executeSingularityFn(\r\n        address[] calldata mc,\r\n        bytes[] memory data,\r\n        bool forceSuccess\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns (bool[] memory success, bytes[] memory result)\r\n    {\r\n        uint256 len = mc.length;\r\n        success = new bool[](len);\r\n        result = new bytes[](len);\r\n        for (uint256 i = 0; i < len; ) {\r\n            require(\r\n                isMasterContractRegistered[yieldBox.masterContractOf(mc[i])],\r\n                'BeachBar: MC not registered'\r\n            );\r\n            (success[i], result[i]) = mc[i].call(data[i]);\r\n            if (forceSuccess) {\r\n                require(success[i], _getRevertMsg(result[i]));\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n\r\n    /// @notice Set protocol fees address\r\n    function setFeeTo(address feeTo_) external onlyOwner {\r\n        feeTo = feeTo_;\r\n        emit FeeToUpdate(feeTo_);\r\n    }\r\n\r\n    /// @notice Set TAP distributors fees address\r\n    function setFeeVeTap(address feeVeTap_) external onlyOwner {\r\n        feeVeTap = feeVeTap_;\r\n        emit FeeVeTapUpdate(feeVeTap_);\r\n    }\r\n\r\n    /// @notice Used to register and enable or disable swapper contracts used in closed liquidations.\r\n    /// MasterContract Only Admin function.\r\n    /// @param swapper The address of the swapper contract that conforms to `ISwapper`.\r\n    /// @param enable True to enable the swapper. To disable use False.\r\n    function setSwapper(IMultiSwapper swapper, bool enable) external onlyOwner {\r\n        swappers[swapper] = enable;\r\n        emit SwapperUpdate(address(swapper), enable);\r\n    }\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    function _getRevertMsg(bytes memory _returnData)\r\n        private\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\r\n        if (_returnData.length < 68) return 'SGL: no return data';\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Slice the sighash.\r\n            _returnData := add(_returnData, 0x04)\r\n        }\r\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\r\n    }\r\n}\r\n"
    },
    "contracts/IBeachBar.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport './usd0/IUSD0.sol';\nimport './swappers/IMultiSwapper.sol';\n\ninterface IBeachBar {\n    /// @notice swap extra data\n    struct SwapData {\n        uint256 minAssetAmount;\n    }\n\n    /// @notice Used to define the MasterContract's type\n    enum ContractType {\n        lowRisk,\n        mediumRisk,\n        highRisk\n    }\n\n    /// @notice MasterContract address and type\n    struct MasterContract {\n        address location;\n        ContractType risk;\n    }\n\n    function swappers(IMultiSwapper swapper) external view returns (bool);\n\n    function yieldBox() external view returns (address payable);\n\n    function tapToken() external view returns (address);\n\n    function tapAssetId() external view returns (uint256);\n\n    function usdoToken() external view returns (address);\n\n    function usdoAssetId() external view returns (uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeVeTap() external view returns (address);\n}\n"
    },
    "contracts/libraries/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\ninterface ICurvePool {\n    function coins(uint256 i) external view returns (address);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n}\n"
    },
    "contracts/libraries/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/libraries/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport './IUniswapV2Pair.sol';\nimport './SafeMath.sol';\n\n// solhint-disable max-line-length\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            pairCodeHash // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB, pairCodeHash)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(\n            reserveA > 0 && reserveB > 0,\n            'UniswapV2Library: INSUFFICIENT_LIQUIDITY'\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            'UniswapV2Library: INSUFFICIENT_LIQUIDITY'\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            'UniswapV2Library: INSUFFICIENT_LIQUIDITY'\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1],\n                pairCodeHash\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i],\n                pairCodeHash\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/liquidationQueue/bidders/CurveStableToUsdoBidder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\n\nimport '../../IBeachBar.sol';\nimport '../ILiquidationQueue.sol';\nimport '../../libraries/ICurvePool.sol';\nimport '../../swappers/ICurveSwapper.sol';\nimport '../../singularity/interfaces/ISingularity.sol';\nimport '../../../yieldbox/contracts/interfaces/IYieldBox.sol';\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Swaps Stable to USD0 through Curve\n/// @dev Performs a swap operation between stable and USD0 through 3CRV+USD0 pool\ncontract CurveStableToUsdoBidder is BoringOwnable {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    /// @notice 3Crv+USD0 swapper\n    ICurveSwapper public curveSwapper;\n    /// @notice Curve pool assets number\n    uint256 curveAssetsLength;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event CurveSwapperUpdated(address indexed _old, address indexed _new);\n\n    /// @notice creates a new CurveStableToUsdoBidder\n    /// @param curveSwapper_ CurveSwapper address\n    /// @param curvePoolAssetCount_ Curve pool assets number\n    constructor(ICurveSwapper curveSwapper_, uint256 curvePoolAssetCount_) {\n        curveSwapper = curveSwapper_;\n        curveAssetsLength = curvePoolAssetCount_;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the unique name\n    function name() external pure returns (string memory) {\n        return 'stable -> USD0 (3Crv+USD0)';\n    }\n\n    /// @notice returns the amount of collateral\n    /// @param amountIn Stablecoin amount\n    function getOutputAmount(\n        ISingularity mixologist,\n        uint256 tokenInId,\n        uint256 amountIn,\n        bytes calldata\n    ) external view returns (uint256) {\n        require(\n            IBeachBar(mixologist.beachBar()).usdoToken() != address(0),\n            'USD0 not set'\n        );\n\n        uint256 usdoAssetId = IBeachBar(mixologist.beachBar()).usdoAssetId();\n        if (tokenInId == usdoAssetId) {\n            return amountIn;\n        }\n\n        return\n            _getOutput(\n                IYieldBox(mixologist.yieldBox()),\n                tokenInId,\n                usdoAssetId,\n                amountIn\n            );\n    }\n\n    /// @notice returns token tokenIn amount based on tokenOut amount\n    /// @param tokenInId Token in asset id\n    /// @param amountOut Token out amount\n    function getInputAmount(\n        ISingularity mixologist,\n        uint256 tokenInId,\n        uint256 amountOut,\n        bytes calldata\n    ) external view returns (uint256) {\n        require(\n            IBeachBar(mixologist.beachBar()).usdoToken() != address(0),\n            'USD0 not set'\n        );\n\n        uint256 usdoAssetId = IBeachBar(mixologist.beachBar()).usdoAssetId();\n        if (tokenInId == usdoAssetId) {\n            return amountOut;\n        }\n\n        return\n            _getOutput(\n                IYieldBox(mixologist.yieldBox()),\n                usdoAssetId,\n                tokenInId,\n                amountOut\n            );\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice swaps stable to collateral\n    /// @param tokenInId Stablecoin asset id\n    /// @param amountIn Stablecoin amount\n    /// @param data extra data used for the swap operation\n    function swap(\n        ISingularity mixologist,\n        uint256 tokenInId,\n        uint256 amountIn,\n        bytes calldata data\n    ) external returns (uint256) {\n        require(\n            IBeachBar(mixologist.beachBar()).usdoToken() != address(0),\n            'USD0 not set'\n        );\n        IYieldBox yieldBox = IYieldBox(mixologist.yieldBox());\n        ILiquidationQueue liquidationQueue = ILiquidationQueue(\n            mixologist.liquidationQueue()\n        );\n\n        uint256 usdoAssetId = IBeachBar(mixologist.beachBar()).usdoAssetId();\n        require(msg.sender == address(liquidationQueue), 'only LQ');\n        if (tokenInId == usdoAssetId) {\n            yieldBox.transfer(\n                address(this),\n                address(liquidationQueue),\n                tokenInId,\n                yieldBox.toShare(tokenInId, amountIn, false)\n            );\n            return amountIn;\n        }\n\n        uint256 _usdoMin = 0;\n        if (data.length > 0) {\n            //should always be sent\n            _usdoMin = abi.decode(data, (uint256));\n        }\n        yieldBox.transfer(\n            address(this),\n            address(curveSwapper),\n            tokenInId,\n            yieldBox.toShare(tokenInId, amountIn, false)\n        );\n        return\n            _swap(\n                yieldBox,\n                tokenInId,\n                usdoAssetId,\n                amountIn,\n                _usdoMin,\n                address(liquidationQueue)\n            );\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the Curve swapper\n    /// @dev used for USD0 to WETH swap\n    /// @param _swapper The curve pool swapper address\n    function setCurveSwapper(ICurveSwapper _swapper) external onlyOwner {\n        emit CurveSwapperUpdated(address(curveSwapper), address(_swapper));\n        curveSwapper = _swapper;\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getCurveIndex(address token) private view returns (uint256) {\n        int256 index = -1;\n        for (uint256 i = 0; i < curveAssetsLength; i++) {\n            address tokenAtIndex = ICurvePool(curveSwapper.curvePool()).coins(\n                i\n            );\n            if (tokenAtIndex == token) {\n                index = int256(i);\n            }\n        }\n        require(index > -1, 'asset not found');\n        return uint256(index);\n    }\n\n    function _getOutput(\n        IYieldBox yieldBox,\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256 amountIn\n    ) private view returns (uint256) {\n        (, address tokenInAddress, , ) = yieldBox.assets(tokenInId);\n        (, address tokenOutAddress, , ) = yieldBox.assets(tokenOutId);\n\n        uint256 tokenInCurveIndex = _getCurveIndex(tokenInAddress);\n        uint256 tokenOutCurveIndex = _getCurveIndex(tokenOutAddress);\n        uint256[] memory indexes = new uint256[](2);\n        indexes[0] = tokenInCurveIndex;\n        indexes[1] = tokenOutCurveIndex;\n\n        uint256 share = yieldBox.toShare(tokenInId, amountIn, false);\n        return curveSwapper.getOutputAmount(tokenInId, indexes, share);\n    }\n\n    function _swap(\n        IYieldBox yieldBox,\n        uint256 stableAssetId,\n        uint256 usdoAssetId,\n        uint256 amountIn,\n        uint256 minAmount,\n        address to\n    ) private returns (uint256) {\n        (, address tokenInAddress, , ) = yieldBox.assets(stableAssetId);\n        (, address tokenOutAddress, , ) = yieldBox.assets(usdoAssetId);\n\n        uint256 tokenInCurveIndex = _getCurveIndex(tokenInAddress);\n        uint256 tokenOutCurveIndex = _getCurveIndex(tokenOutAddress);\n\n        uint256[] memory indexes = new uint256[](2);\n        indexes[0] = tokenInCurveIndex;\n        indexes[1] = tokenOutCurveIndex;\n        uint256 tokenInShare = yieldBox.toShare(stableAssetId, amountIn, false);\n\n        (uint256 amountOut, ) = curveSwapper.swap(\n            stableAssetId,\n            usdoAssetId,\n            indexes,\n            tokenInShare,\n            minAmount,\n            to\n        );\n\n        return amountOut;\n    }\n}\n"
    },
    "contracts/liquidationQueue/bidders/IBidder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @notice Used for performing swap operations when bidding on LiquidationQueue\ninterface IBidder {\n    /// @notice returns the unique name\n    function name() external view returns (string memory);\n\n    /// @notice returns the amount of collateral\n    /// @param mixologist Market to query for\n    /// @param tokenInId Token in YieldBox asset id\n    /// @param amountIn Token in amount\n    /// @param data extra data used for retrieving the ouput\n    function getOutputAmount(\n        address mixologist,\n        uint256 tokenInId,\n        uint256 amountIn,\n        bytes calldata data\n    ) external view returns (uint256);\n\n    /// @notice swap USD0 to collateral\n    /// @param mixologist Market to swap for\n    /// @param tokenInId Token in asset id\n    /// @param amountIn Token in amount\n    /// @param data extra data used for the swap operation\n    function swap(\n        address mixologist,\n        uint256 tokenInId,\n        uint256 amountIn,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /// @notice returns token tokenIn amount based on tokenOut amount\n    /// @param mixologist Market to query for\n    /// @param tokenInId Token in asset id\n    /// @param amountOut Token out amount\n    /// @param data extra data used for retrieving the ouput\n    function getInputAmount(\n        address mixologist,\n        uint256 tokenInId,\n        uint256 amountOut,\n        bytes calldata data\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/liquidationQueue/bidders/UniUsdoToWethBidder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\n\nimport '../../IBeachBar.sol';\nimport '../ILiquidationQueue.sol';\nimport '../../swappers/IMultiSwapper.sol';\nimport '../../singularity/interfaces/ISingularity.sol';\nimport '../../../yieldbox/contracts/interfaces/IYieldBox.sol';\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Swaps USD0 to WETH UniswapV2\n/// @dev Performs 1 swap operation:\n///     - USD0 to Weth through UniV2\ncontract UniUsdoToWethBidder is BoringOwnable {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    /// @notice UniswapV2 swapper\n    IMultiSwapper public univ2Swapper;\n\n    /// @notice YieldBox WETH asset id\n    uint256 wethId;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event UniV2SwapperUpdated(address indexed _old, address indexed _new);\n\n    /// @notice Creates a new UniUsdoToWethBidder contract\n    /// @param uniV2Swapper_ UniswapV2 swapper address\n    /// @param _wethAssetId YieldBox WETH asset id\n    constructor(IMultiSwapper uniV2Swapper_, uint256 _wethAssetId) {\n        univ2Swapper = uniV2Swapper_;\n        wethId = _wethAssetId;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the unique name\n    function name() external pure returns (string memory) {\n        return 'USD0 -> WETH (Uniswap V2)';\n    }\n\n    /// @notice returns token tokenIn amount based on tokenOut amount\n    /// @param tokenInId Token in asset id\n    /// @param amountOut Token out amount\n    function getInputAmount(\n        ISingularity mixologist,\n        uint256 tokenInId,\n        uint256 amountOut,\n        bytes calldata\n    ) external view returns (uint256) {\n        require(\n            tokenInId == IBeachBar(mixologist.beachBar()).usdoAssetId(),\n            'token not valid'\n        );\n        IYieldBox yieldBox = IYieldBox(mixologist.yieldBox());\n\n        uint256 shareOut = yieldBox.toShare(wethId, amountOut, false);\n\n        (, address tokenInAddress, , ) = yieldBox.assets(tokenInId);\n        (, address tokenOutAddress, , ) = yieldBox.assets(wethId);\n\n        address[] memory path = new address[](2);\n        path[0] = tokenInAddress;\n        path[1] = tokenOutAddress;\n\n        return univ2Swapper.getInputAmount(wethId, path, shareOut);\n    }\n\n    /// @notice returns the amount of collateral\n    /// @param amountIn Stablecoin amount\n    function getOutputAmount(\n        ISingularity mixologist,\n        uint256 tokenInId,\n        uint256 amountIn,\n        bytes calldata\n    ) external view returns (uint256) {\n        require(\n            IBeachBar(mixologist.beachBar()).usdoToken() != address(0),\n            'USD0 not set'\n        );\n        uint256 usdoAssetId = IBeachBar(mixologist.beachBar()).usdoAssetId();\n        require(tokenInId == usdoAssetId, 'token not valid');\n\n        return\n            _uniswapOutputAmount(\n                IYieldBox(mixologist.yieldBox()),\n                usdoAssetId,\n                wethId,\n                amountIn\n            );\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice swaps stable to collateral\n    /// @param tokenInId Token in asset Id\n    /// @param amountIn Stablecoin amount\n    /// @param data extra data used for the swap operation\n    function swap(\n        ISingularity mixologist,\n        uint256 tokenInId,\n        uint256 amountIn,\n        bytes calldata data\n    ) external returns (uint256) {\n        require(\n            IBeachBar(mixologist.beachBar()).usdoToken() != address(0),\n            'USD0 not set'\n        );\n        IYieldBox yieldBox = IYieldBox(mixologist.yieldBox());\n        ILiquidationQueue liquidationQueue = ILiquidationQueue(\n            mixologist.liquidationQueue()\n        );\n\n        uint256 usdoAssetId = IBeachBar(mixologist.beachBar()).usdoAssetId();\n        require(tokenInId == usdoAssetId, 'token not valid');\n        require(msg.sender == address(liquidationQueue), 'only LQ');\n\n        uint256 assetMin = 0;\n        if (data.length > 0) {\n            //should always be sent\n            assetMin = abi.decode(data, (uint256));\n        }\n\n        yieldBox.transfer(\n            address(this),\n            address(univ2Swapper),\n            tokenInId,\n            yieldBox.toShare(tokenInId, amountIn, false)\n        );\n\n        return\n            _uniswapSwap(\n                yieldBox,\n                usdoAssetId,\n                wethId,\n                amountIn,\n                assetMin,\n                address(liquidationQueue)\n            );\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the UniV2 swapper\n    /// @dev used for WETH to USDC swap\n    /// @param _swapper The UniV2 pool swapper address\n    function setUniswapSwapper(IMultiSwapper _swapper) external onlyOwner {\n        emit UniV2SwapperUpdated(address(univ2Swapper), address(_swapper));\n        univ2Swapper = _swapper;\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _uniswapSwap(\n        IYieldBox yieldBox,\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256 tokenInAmount,\n        uint256 minAmount,\n        address to\n    ) private returns (uint256) {\n        (, address tokenInAddress, , ) = yieldBox.assets(tokenInId);\n        (, address tokenOutAddress, , ) = yieldBox.assets(tokenOutId);\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = tokenInAddress;\n        swapPath[1] = tokenOutAddress;\n        uint256 tokenInShare = yieldBox.toShare(\n            tokenInId,\n            tokenInAmount,\n            false\n        );\n        (uint256 outAmount, ) = univ2Swapper.swap(\n            tokenInId,\n            tokenOutId,\n            minAmount,\n            to,\n            swapPath,\n            tokenInShare\n        );\n\n        return outAmount;\n    }\n\n    function _uniswapOutputAmount(\n        IYieldBox yieldBox,\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256 amountIn\n    ) private view returns (uint256) {\n        (, address tokenInAddress, , ) = yieldBox.assets(tokenInId);\n        (, address tokenOutAddress, , ) = yieldBox.assets(tokenOutId);\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = tokenInAddress;\n        swapPath[1] = tokenOutAddress;\n        uint256 tokenInShare = yieldBox.toShare(tokenInId, amountIn, false);\n        return univ2Swapper.getOutputAmount(tokenInId, swapPath, tokenInShare);\n    }\n}\n"
    },
    "contracts/liquidationQueue/ILiquidationQueue.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport './bidders/IBidder.sol';\n\ninterface ILiquidationQueue {\n    enum MODE {\n        ADD,\n        SUB\n    }\n\n    struct Bidder {\n        bool isUsdo;\n        bool swapOnExecute;\n        uint256 usdoAmount;\n        uint256 liquidatedAssetAmount;\n        uint256 timestamp; // Timestamp in second of the last bid.\n    }\n\n    struct OrderBookPoolEntry {\n        address bidder;\n        Bidder bidInfo;\n    }\n\n    struct OrderBookPoolInfo {\n        uint32 poolId;\n        uint32 nextBidPull; // Next position in `entries` to start pulling bids from\n        uint32 nextBidPush; // Next position in `entries` to start pushing bids to\n    }\n\n    struct LiquidationQueueMeta {\n        uint256 activationTime; // Time needed before a bid can be activated for execution\n        uint256 minBidAmount; // Minimum bid amount\n        address feeCollector; // Address of the fee collector\n        IBidder bidExecutionSwapper; //Allows swapping USD0 to collateral when a bid is executed\n        IBidder usdoSwapper; //Allows swapping any other stablecoin to USD0\n    }\n    \n    struct BidExecutionData {\n        uint256 curPoolId;\n        bool isBidAvail;\n        OrderBookPoolInfo poolInfo;\n        OrderBookPoolEntry orderBookEntry;\n        OrderBookPoolEntry orderBookEntryCopy;\n        uint256 totalPoolAmountExecuted;\n        uint256 totalPoolCollateralLiquidated;\n        uint256 totalUsdoAmountUsed;\n        uint256 exchangeRate;\n        uint256 discountedBidderAmount;\n    }\n\n    function init(LiquidationQueueMeta calldata, address mixologist) external;\n\n    function onlyOnce() external view returns (bool);\n\n    function setBidExecutionSwapper(address swapper) external;\n\n    function setUsdoSwapper(address swapper) external;\n\n    function getNextAvailBidPool()\n        external\n        view\n        returns (uint256 i, bool available);\n\n    function executeBids(\n        uint256 collateralAmountToLiquidate,\n        bytes calldata swapData\n    ) external returns (uint256 amountExecuted, uint256 collateralLiquidated);\n}\n"
    },
    "contracts/liquidationQueue/LiquidationQueue.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\n\nimport '../IBeachBar.sol';\nimport './ILiquidationQueue.sol';\nimport '../singularity/interfaces/ISingularity.sol';\nimport '../../yieldbox/contracts/interfaces/IStrategy.sol';\n\nimport '../../yieldbox/contracts/YieldBox.sol';\n\n/// @title LiquidationQueue\n/// @author @0xRektora, TapiocaDAO\n// TODO: Capital efficiency? (register assets to strategies) (farm strat for TAP)\n// TODO: ERC20 impl?\ncontract LiquidationQueue is ILiquidationQueue {\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n\n    /**\n     * General information about the LiquidationQueue contract.\n     */\n\n    /// @notice returns metadata information\n    LiquidationQueueMeta public liquidationQueueMeta;\n    /// @notice targeted market\n    ISingularity public mixologist;\n    /// @notice BeachBar addres\n    IBeachBar public beachBar;\n    /// @notice YieldBox address\n    YieldBox public yieldBox;\n\n    /// @notice liquidation queue BeachBar asset id\n    uint256 public lqAssetId;\n    /// @notice mixologist asset id\n    uint256 public marketAssetId;\n    /// @notice asset that is being liquidated\n    uint256 public liquidatedAssetId;\n\n    /// @notice initialization status\n    bool public onlyOnce;\n\n    /**\n     * Pools & order books information.\n     */\n\n    /// @notice Bid pools\n    /// @dev x% premium => bid pool\n    ///      0 ... 30 range\n    ///      poolId => userAddress => userBidInfo.\n    mapping(uint256 => mapping(address => Bidder)) public bidPools;\n\n    /// @notice The actual order book. Entries are stored only once a bid has been activated\n    /// @dev poolId => bidIndex => bidEntry).\n    mapping(uint256 => mapping(uint256 => OrderBookPoolEntry))\n        public orderBookEntries;\n    /// @notice Meta-data about the order book pool\n    /// @dev poolId => poolInfo.\n    mapping(uint256 => OrderBookPoolInfo) public orderBookInfos;\n\n    /**\n     * Ledger.\n     */\n\n    /// @notice User current bids\n    /// @dev user => orderBookEntries[poolId][bidIndex]\n    mapping(address => mapping(uint256 => uint256[])) public userBidIndexes;\n\n    /// @notice Due balance of users\n    /// @dev user => amountDue.\n    mapping(address => uint256) public balancesDue;\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n\n    uint256 constant MAX_BID_POOLS = 10; // Maximum amount of pools.\n    // `amount` * ((`bidPool` * `PREMIUM_FACTOR`) / `PREMIUM_FACTOR_PRECISION`) = premium.\n    uint256 constant PREMIUM_FACTOR = 100; // Premium factor.\n    uint256 constant PREMIUM_FACTOR_PRECISION = 10_000; // Precision of the premium factor.\n\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\n\n    uint256 private constant WITHDRAWAL_FEE = 50; // 0.5%\n    uint256 private constant WITHDRAWAL_FEE_PRECISION = 10_000;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n\n    event Bid(\n        address indexed caller,\n        address indexed bidder,\n        uint256 indexed pool,\n        uint256 usdoAmount,\n        uint256 liquidatedAssetAmount,\n        uint256 timestamp\n    );\n\n    event ActivateBid(\n        address indexed caller,\n        address indexed bidder,\n        uint256 indexed pool,\n        uint256 usdoAmount,\n        uint256 liquidatedAssetAmount,\n        uint256 collateralValue,\n        uint256 timestamp\n    );\n\n    event RemoveBid(\n        address indexed caller,\n        address indexed bidder,\n        uint256 indexed pool,\n        uint256 usdoAmount,\n        uint256 liquidatedAssetAmount,\n        uint256 collateralValue,\n        uint256 timestamp\n    );\n\n    event ExecuteBids(\n        address indexed caller,\n        uint256 indexed pool,\n        uint256 usdoAmountExecuted,\n        uint256 liquidatedAssetAmountExecuted,\n        uint256 collateralLiquidated,\n        uint256 timestamp\n    );\n\n    event Redeem(address indexed redeemer, address indexed to, uint256 amount);\n    event BidSwapperUpdated(IBidder indexed _old, address indexed _new);\n    event UsdoSwapperUpdated(IBidder indexed _old, address indexed _new);\n\n    // ***************** //\n    // *** MODIFIERS *** //\n    // ***************** //\n\n    modifier Active() {\n        require(onlyOnce, 'LQ: Not initialized');\n        _;\n    }\n\n    /// @notice Acts as a 'constructor', should be called by a Singularity market.\n    /// @param  _liquidationQueueMeta Info about the liquidations.\n    function init(\n        LiquidationQueueMeta calldata _liquidationQueueMeta,\n        address _mixologist\n    ) external override {\n        require(!onlyOnce, 'LQ: Initialized');\n\n        liquidationQueueMeta = _liquidationQueueMeta;\n\n        mixologist = ISingularity(_mixologist);\n        liquidatedAssetId = mixologist.collateralId();\n        marketAssetId = mixologist.assetId();\n        beachBar = IBeachBar(mixologist.beachBar());\n        yieldBox = YieldBox(mixologist.yieldBox());\n\n        lqAssetId = _registerAsset();\n\n        IERC20(mixologist.asset()).approve(\n            address(yieldBox),\n            type(uint256).max\n        );\n        yieldBox.setApprovalForAll(address(mixologist), true);\n\n        // We initialize the pools to save gas on conditionals later on.\n        for (uint256 i = 0; i <= MAX_BID_POOLS; ) {\n            _initOrderBookPoolInfo(i);\n            ++i;\n        }\n\n        onlyOnce = true; // We set the init flag.\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n\n    /// @notice returns targeted market\n    function market() public view returns (string memory) {\n        return mixologist.name();\n    }\n\n    /// @notice returns order book size\n    function getOrderBookSize(uint256 pool) public view returns (uint256 size) {\n        OrderBookPoolInfo memory poolInfo = orderBookInfos[pool];\n        unchecked {\n            size = poolInfo.nextBidPush - poolInfo.nextBidPull;\n        }\n    }\n\n    /// @notice returns an array of 'OrderBookPoolEntry' for a pool\n    function getOrderBookPoolEntries(uint256 pool)\n        external\n        view\n        returns (OrderBookPoolEntry[] memory x)\n    {\n        OrderBookPoolInfo memory poolInfo = orderBookInfos[pool];\n        uint256 orderBookSize = poolInfo.nextBidPush - poolInfo.nextBidPull;\n\n        x = new OrderBookPoolEntry[](orderBookSize); // Initialize the return array.\n\n        mapping(uint256 => OrderBookPoolEntry)\n            storage entries = orderBookEntries[pool];\n        for (\n            (uint256 i, uint256 j) = (poolInfo.nextBidPull, 0);\n            i < poolInfo.nextBidPush;\n\n        ) {\n            x[j] = entries[i]; // Copy the entry to the return array.\n\n            unchecked {\n                ++i;\n                ++j;\n            }\n        }\n    }\n\n    /// @notice Get the next not empty bid pool in ASC order.\n    /// @return i The bid pool id.\n    /// @return available True if there is at least 1 bid available across all the order books.\n    function getNextAvailBidPool()\n        public\n        view\n        override\n        returns (uint256 i, bool available)\n    {\n        for (; i <= MAX_BID_POOLS; ) {\n            if (getOrderBookSize(i) != 0) {\n                available = true;\n                break;\n            }\n            ++i;\n        }\n    }\n\n    /// @notice returns number of pool bids for user\n    function userBidIndexLength(address user, uint256 pool)\n        external\n        view\n        returns (uint256 len)\n    {\n        uint256[] memory bidIndexes = userBidIndexes[user][pool];\n\n        uint256 bidIndexesLen = bidIndexes.length;\n        OrderBookPoolInfo memory poolInfo = orderBookInfos[pool];\n        for (uint256 i = 0; i < bidIndexesLen; ) {\n            if (bidIndexes[i] >= poolInfo.nextBidPull) {\n                bidIndexesLen--;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return bidIndexes.length;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Add a bid to a bid pool using stablecoins.\n    /// @dev Works the same way as `bid` but performs a swap from the stablecoin to USDO\n    ///      - if stableAssetId == usdoAssetId, no swap is performed\n    /// @param user The bidder\n    /// @param pool To which pool the bid should go\n    /// @param stableAssetId Stablecoin YieldBox asset id\n    /// @param amountIn Stablecoin amount\n    /// @param data Extra data for swap operations\n    function bidWithStable(\n        address user,\n        uint256 pool,\n        uint256 stableAssetId,\n        uint256 amountIn,\n        bytes calldata data\n    ) external Active {\n        require(pool <= MAX_BID_POOLS, 'LQ: premium too high');\n        require(\n            address(liquidationQueueMeta.usdoSwapper) != address(0),\n            'LQ: USD0 swapper not set'\n        );\n\n        uint256 usdoAssetId = beachBar.usdoAssetId();\n        yieldBox.transfer(\n            msg.sender,\n            address(liquidationQueueMeta.usdoSwapper),\n            stableAssetId,\n            yieldBox.toShare(stableAssetId, amountIn, false)\n        );\n\n        uint256 usdoAmount = liquidationQueueMeta.usdoSwapper.swap(\n            address(mixologist),\n            stableAssetId,\n            amountIn,\n            data\n        );\n\n        Bidder memory bidder = _bid(user, pool, usdoAmount, true);\n\n        uint256 usdoValueInLqAsset = bidder.swapOnExecute\n            ? liquidationQueueMeta.bidExecutionSwapper.getOutputAmount(\n                address(mixologist),\n                usdoAssetId,\n                usdoAmount,\n                data\n            )\n            : bidder.usdoAmount;\n\n        require(\n            usdoValueInLqAsset >= liquidationQueueMeta.minBidAmount,\n            'LQ: bid too low'\n        );\n    }\n\n    /// @notice Add a bid to a bid pool.\n    /// @dev Create an entry in `bidPools`.\n    ///      Clean the userBidIndex here instead of the `executeBids()` function to save on gas.\n    /// @param user The bidder.\n    /// @param pool To which pool the bid should go.\n    /// @param amount The amount in asset to bid.\n    function bid(\n        address user,\n        uint256 pool,\n        uint256 amount\n    ) external Active {\n        require(pool <= MAX_BID_POOLS, 'LQ: premium too high');\n        require(amount >= liquidationQueueMeta.minBidAmount, 'LQ: bid too low');\n\n        // Transfer assets to the LQ contract.\n        uint256 assetId = lqAssetId;\n        yieldBox.transfer(\n            msg.sender,\n            address(this),\n            assetId,\n            yieldBox.toShare(assetId, amount, false)\n        );\n        _bid(user, pool, amount, false);\n    }\n\n    /// @notice Activate a bid by putting it in the order book.\n    /// @dev Create an entry in `orderBook` and remove it from `bidPools`.\n    /// @dev Spam vector attack is mitigated the min amount req., 10min CD + activation fees.\n    /// @param user The user to activate the bid for.\n    /// @param pool The target pool.\n    function activateBid(address user, uint256 pool) external {\n        Bidder memory bidder = bidPools[pool][user];\n        require(\n            block.timestamp >=\n                bidder.timestamp + liquidationQueueMeta.activationTime,\n            'LQ: too soon'\n        );\n\n        OrderBookPoolInfo memory poolInfo = orderBookInfos[pool]; // Info about the pool array indexes.\n\n        // Create a new order book entry.\n        OrderBookPoolEntry memory orderBookEntry;\n        orderBookEntry.bidder = user;\n        orderBookEntry.bidInfo = bidder;\n\n        // Insert the order book entry and delete the bid entry from the given pool.\n        orderBookEntries[pool][poolInfo.nextBidPush] = orderBookEntry;\n        delete bidPools[pool][user];\n\n        // Add the index to the user bid index.\n        userBidIndexes[user][pool].push(poolInfo.nextBidPush);\n\n        // Update the `orderBookInfos`.\n        unchecked {\n            ++poolInfo.nextBidPush;\n        }\n        orderBookInfos[pool] = poolInfo;\n\n        uint256 bidAmount = orderBookEntry.bidInfo.isUsdo\n            ? orderBookEntry.bidInfo.usdoAmount\n            : orderBookEntry.bidInfo.liquidatedAssetAmount;\n        emit ActivateBid(\n            msg.sender,\n            user,\n            pool,\n            orderBookEntry.bidInfo.usdoAmount,\n            orderBookEntry.bidInfo.liquidatedAssetAmount,\n            orderBookEntry.bidInfo.swapOnExecute\n                ? liquidationQueueMeta.bidExecutionSwapper.getOutputAmount(\n                    address(mixologist),\n                    beachBar.usdoAssetId(),\n                    orderBookEntry.bidInfo.usdoAmount,\n                    ''\n                )\n                : bidAmount,\n            block.timestamp\n        );\n    }\n\n    /// @notice Remove a not yet activated bid from the bid pool.\n    /// @dev Remove `msg.sender` funds.\n    /// @param user The user to send the funds to.\n    /// @param pool The pool to remove the bid from.\n    /// @return amountRemoved The amount of the bid.\n    function removeInactivatedBid(address user, uint256 pool)\n        external\n        returns (uint256 amountRemoved)\n    {\n        bool isUsdo = bidPools[pool][msg.sender].isUsdo;\n        amountRemoved = isUsdo\n            ? bidPools[pool][msg.sender].usdoAmount\n            : bidPools[pool][msg.sender].liquidatedAssetAmount;\n        delete bidPools[pool][msg.sender];\n\n        uint256 lqAssetValue = amountRemoved;\n        if (bidPools[pool][msg.sender].swapOnExecute) {\n            lqAssetValue = liquidationQueueMeta\n                .bidExecutionSwapper\n                .getOutputAmount(\n                    address(mixologist),\n                    beachBar.usdoAssetId(),\n                    amountRemoved,\n                    ''\n                );\n        }\n        require(\n            lqAssetValue >= liquidationQueueMeta.minBidAmount,\n            'LQ: bid does not exist'\n        ); //save gas\n\n        // Transfer assets\n        uint256 assetId = isUsdo ? beachBar.usdoAssetId() : lqAssetId;\n        yieldBox.transfer(\n            address(this),\n            user,\n            assetId,\n            yieldBox.toShare(assetId, amountRemoved, false)\n        );\n\n        emit RemoveBid(\n            msg.sender,\n            user,\n            pool,\n            isUsdo ? amountRemoved : 0,\n            isUsdo ? 0 : amountRemoved,\n            lqAssetValue,\n            block.timestamp\n        );\n    }\n\n    /// @notice Remove an activated bid from a given pool.\n    /// @dev Clean the userBidIndex here instead of the `executeBids()` function to save on gas.\n    ///      To prevent DoS attacks on `executeBids()` and gas costs, the last activated bid\n    ///      will take the position of the removed bid.\n    /// @param user The user to send the funds to.\n    /// @param pool The target pool.\n    /// @param bidPosition The position of the bid index inside the `userBidIndexes[msg.sender][pool]`.\n    /// @return amountRemoved The amount of the bid removed.\n    function removeBid(\n        address user,\n        uint256 pool,\n        uint256 bidPosition\n    ) external returns (uint256 amountRemoved) {\n        uint256[] storage bidIndexes = userBidIndexes[msg.sender][pool];\n        uint256 bidIndexesLen = bidIndexes.length;\n        OrderBookPoolInfo memory poolInfo = orderBookInfos[pool];\n\n        uint256 orderBookIndex = bidIndexes[bidPosition];\n        bool isUsdo = orderBookEntries[pool][orderBookIndex].bidInfo.isUsdo;\n\n        amountRemoved = isUsdo\n            ? orderBookEntries[pool][orderBookIndex].bidInfo.usdoAmount\n            : orderBookEntries[pool][orderBookIndex]\n                .bidInfo\n                .liquidatedAssetAmount;\n\n        // Clean expired bids.\n        for (uint256 i = 0; i < bidIndexesLen; ) {\n            if (bidIndexes[i] > poolInfo.nextBidPull) {\n                bidIndexesLen = bidIndexes.length;\n                bidIndexes[i] = bidIndexes[bidIndexesLen - 1];\n                bidIndexes.pop();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        // There might be a case when all bids are expired\n        if (bidIndexes.length > 0) {\n            // Remove bid from the order book by replacing it with the last activated bid.\n            orderBookIndex = bidIndexes[bidPosition];\n            isUsdo = orderBookEntries[pool][orderBookIndex].bidInfo.isUsdo;\n            amountRemoved = isUsdo\n                ? orderBookEntries[pool][orderBookIndex].bidInfo.usdoAmount\n                : orderBookEntries[pool][orderBookIndex]\n                    .bidInfo\n                    .liquidatedAssetAmount;\n            orderBookEntries[pool][orderBookIndex] = orderBookEntries[pool][\n                poolInfo.nextBidPush - 1\n            ];\n\n            // Remove latest userBidIndex\n            bidIndexesLen = bidIndexes.length;\n            bidIndexes[bidPosition] = bidIndexes[bidIndexesLen - 1];\n            bidIndexes.pop();\n        }\n        // Transfer assets\n        uint256 assetId = isUsdo ? beachBar.usdoAssetId() : lqAssetId;\n        yieldBox.transfer(\n            address(this),\n            user,\n            assetId,\n            yieldBox.toShare(assetId, amountRemoved, false)\n        );\n        uint256 lqAssetValue = amountRemoved;\n        if (orderBookEntries[pool][orderBookIndex].bidInfo.swapOnExecute) {\n            lqAssetValue = liquidationQueueMeta\n                .bidExecutionSwapper\n                .getOutputAmount(\n                    address(mixologist),\n                    beachBar.usdoAssetId(),\n                    amountRemoved,\n                    ''\n                );\n        }\n        emit RemoveBid(\n            msg.sender,\n            user,\n            pool,\n            isUsdo ? amountRemoved : 0,\n            isUsdo ? 0 : amountRemoved,\n            lqAssetValue,\n            block.timestamp\n        );\n    }\n\n    /// @notice Redeem a balance.\n    /// @dev `msg.sender` is used as the redeemer.\n    /// @param to The address to redeem to.\n    function redeem(address to) external {\n        require(balancesDue[msg.sender] > 0, 'LQ: No balance due');\n\n        uint256 balance = balancesDue[msg.sender];\n        uint256 fee = (balance * WITHDRAWAL_FEE) / WITHDRAWAL_FEE_PRECISION;\n        uint256 redeemable = balance - fee;\n\n        balancesDue[msg.sender] = 0;\n        balancesDue[liquidationQueueMeta.feeCollector] += fee;\n\n        uint256 assetId = liquidatedAssetId;\n        yieldBox.transfer(\n            address(this),\n            to,\n            assetId,\n            yieldBox.toShare(assetId, redeemable, false)\n        );\n\n        emit Redeem(msg.sender, to, redeemable);\n    }\n\n    /// @notice Execute the liquidation call by executing the bids placed in the pools in ASC order.\n    /// @dev Should only be called from Singularity.\n    ///      Singularity should send the `collateralAmountToLiquidate` to this contract before calling this function.\n    /// Tx will fail if it can't transfer allowed BeachBar asset from Singularity.\n    /// @param collateralAmountToLiquidate The amount of collateral to liquidate.\n    /// @param swapData Swap data necessary for swapping USD0 to market asset; necessary only if bidder added USD0\n    /// @return totalAmountExecuted The amount of asset that was executed.\n    /// @return totalCollateralLiquidated The amount of collateral that was liquidated.\n    function executeBids(\n        uint256 collateralAmountToLiquidate,\n        bytes calldata swapData\n    )\n        external\n        override\n        returns (uint256 totalAmountExecuted, uint256 totalCollateralLiquidated)\n    {\n        require(msg.sender == address(mixologist), 'LQ: Only Singularity');\n        BidExecutionData memory data;\n\n        (data.curPoolId, data.isBidAvail) = getNextAvailBidPool();\n        data.exchangeRate = mixologist.exchangeRate();\n        // We loop through all the bids for each pools until all the collateral is liquidated\n        // or no more bid are available.\n        while (collateralAmountToLiquidate > 0 && data.isBidAvail) {\n            data.poolInfo = orderBookInfos[data.curPoolId];\n            // Reset pool vars.\n            data.totalPoolAmountExecuted = 0;\n            data.totalPoolCollateralLiquidated = 0;\n            // While bid pool is not empty and we haven't liquidated enough collateral.\n            while (\n                collateralAmountToLiquidate > 0 &&\n                data.poolInfo.nextBidPull != data.poolInfo.nextBidPush\n            ) {\n                // Get the next bid.\n                data.orderBookEntry = orderBookEntries[data.curPoolId][\n                    data.poolInfo.nextBidPull\n                ];\n                data.orderBookEntryCopy = data.orderBookEntry;\n\n                // Get the total amount of asset with the pool discount applied for the bidder.\n                data\n                    .discountedBidderAmount = _viewBidderDiscountedCollateralAmount(\n                    data.orderBookEntryCopy.bidInfo,\n                    data.exchangeRate,\n                    data.curPoolId\n                );\n\n                // Check if the bidder can pay the remaining collateral to liquidate `collateralAmountToLiquidate`.\n                if (data.discountedBidderAmount > collateralAmountToLiquidate) {\n                    (\n                        uint256 finalDiscountedCollateralAmount,\n                        uint256 finalUsdoAmount\n                    ) = _userPartiallyBidAmount(\n                            data.orderBookEntryCopy.bidInfo,\n                            collateralAmountToLiquidate,\n                            data.exchangeRate,\n                            data.curPoolId,\n                            swapData\n                        );\n\n                    // Execute the bid.\n                    balancesDue[\n                        data.orderBookEntryCopy.bidder\n                    ] += collateralAmountToLiquidate; // Write balance.\n\n                    if (!data.orderBookEntry.bidInfo.isUsdo) {\n                        data\n                            .orderBookEntry\n                            .bidInfo\n                            .liquidatedAssetAmount -= finalDiscountedCollateralAmount; // Update bid entry amount.\n                    } else {\n                        data\n                            .orderBookEntry\n                            .bidInfo\n                            .usdoAmount -= finalUsdoAmount;\n                    }\n\n                    // Update the total amount executed, the total collateral liquidated and collateral to liquidate.\n                    data\n                        .totalPoolAmountExecuted += finalDiscountedCollateralAmount;\n                    data\n                        .totalPoolCollateralLiquidated += collateralAmountToLiquidate;\n                    collateralAmountToLiquidate = 0; // Since we have liquidated all the collateral.\n                    data.totalUsdoAmountUsed += finalUsdoAmount;\n                } else {\n                    (\n                        uint256 finalCollateralAmount,\n                        uint256 finalDiscountedCollateralAmount,\n                        uint256 finalUsdoAmount\n                    ) = _useEntireBidAmount(\n                            data.orderBookEntryCopy.bidInfo,\n                            data.discountedBidderAmount,\n                            data.exchangeRate,\n                            data.curPoolId,\n                            swapData\n                        );\n\n                    // Execute the bid.\n                    balancesDue[\n                        data.orderBookEntryCopy.bidder\n                    ] += finalDiscountedCollateralAmount; // Write balance.\n                    data.orderBookEntry.bidInfo.usdoAmount = 0; // Update bid entry amount.\n                    data.orderBookEntry.bidInfo.liquidatedAssetAmount = 0; // Update bid entry amount.\n                    // Update the total amount executed, the total collateral liquidated and collateral to liquidate.\n                    data.totalUsdoAmountUsed += finalUsdoAmount;\n                    data.totalPoolAmountExecuted += finalCollateralAmount;\n                    data\n                        .totalPoolCollateralLiquidated += finalDiscountedCollateralAmount;\n\n                    collateralAmountToLiquidate -= finalDiscountedCollateralAmount;\n\n                    // Since the current bid was fulfilled, get the next one.\n                    unchecked {\n                        ++data.poolInfo.nextBidPull;\n                    }\n                }\n            }\n            // Update the totals.\n            totalAmountExecuted += data.totalPoolAmountExecuted;\n            totalCollateralLiquidated += data.totalPoolCollateralLiquidated;\n            orderBookInfos[data.curPoolId] = data.poolInfo; // Update the pool info for the current pool.\n            // Look up for the next available bid pool.\n            (data.curPoolId, data.isBidAvail) = getNextAvailBidPool();\n\n            emit ExecuteBids(\n                msg.sender,\n                data.curPoolId,\n                data.totalUsdoAmountUsed,\n                data.totalPoolAmountExecuted,\n                data.totalPoolCollateralLiquidated,\n                block.timestamp\n            );\n        }\n        // Stack too deep\n        {\n            uint256 toSend = totalAmountExecuted;\n\n            // Transfer the assets to the Singularity.\n            yieldBox.withdraw(\n                lqAssetId,\n                address(this),\n                address(this),\n                toSend,\n                0\n            );\n            yieldBox.depositAsset(\n                marketAssetId,\n                address(this),\n                address(mixologist),\n                toSend,\n                0\n            );\n        }\n    }\n\n    /// @notice updates the bid swapper address\n    /// @param _swapper thew new ICollateralSwaper contract address\n    function setBidExecutionSwapper(address _swapper) external override {\n        require(msg.sender == address(mixologist), 'unauthorized');\n        emit BidSwapperUpdated(\n            liquidationQueueMeta.bidExecutionSwapper,\n            _swapper\n        );\n        liquidationQueueMeta.bidExecutionSwapper = IBidder(_swapper);\n    }\n\n    /// @notice updates the bid swapper address\n    /// @param _swapper thew new ICollateralSwaper contract address\n    function setUsdoSwapper(address _swapper) external override {\n        require(msg.sender == address(mixologist), 'unauthorized');\n        emit UsdoSwapperUpdated(liquidationQueueMeta.usdoSwapper, _swapper);\n        liquidationQueueMeta.usdoSwapper = IBidder(_swapper);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _viewBidderDiscountedCollateralAmount(\n        Bidder memory entry,\n        uint256 exchangeRate,\n        uint256 poolId\n    ) private view returns (uint256) {\n        uint256 bidAmount = entry.isUsdo\n            ? entry.usdoAmount\n            : entry.liquidatedAssetAmount;\n        uint256 liquidatedAssetAmount = entry.swapOnExecute\n            ? liquidationQueueMeta.bidExecutionSwapper.getOutputAmount(\n                address(mixologist),\n                beachBar.usdoAssetId(),\n                entry.usdoAmount,\n                ''\n            )\n            : bidAmount;\n        return\n            _getPremiumAmount(\n                _bidToCollateral(liquidatedAssetAmount, exchangeRate),\n                poolId,\n                MODE.ADD\n            );\n    }\n\n    function _useEntireBidAmount(\n        Bidder memory entry,\n        uint256 discountedBidderAmount,\n        uint256 exchangeRate,\n        uint256 poolId,\n        bytes memory swapData\n    )\n        private\n        returns (\n            uint256 finalCollateralAmount,\n            uint256 finalDiscountedCollateralAmount,\n            uint256 finalUsdoAmount\n        )\n    {\n        finalCollateralAmount = entry.liquidatedAssetAmount;\n        finalDiscountedCollateralAmount = discountedBidderAmount;\n        finalUsdoAmount = entry.usdoAmount;\n        //Execute the swap if USD0 was provided and it's different from the liqudation asset id\n        if (entry.swapOnExecute) {\n            yieldBox.transfer(\n                address(this),\n                address(liquidationQueueMeta.bidExecutionSwapper),\n                beachBar.usdoAssetId(),\n                yieldBox.toShare(\n                    beachBar.usdoAssetId(),\n                    entry.usdoAmount,\n                    false\n                )\n            );\n\n            finalCollateralAmount = liquidationQueueMeta\n                .bidExecutionSwapper\n                .swap(\n                    address(mixologist),\n                    beachBar.usdoAssetId(),\n                    entry.usdoAmount,\n                    swapData\n                );\n            finalDiscountedCollateralAmount = _getPremiumAmount(\n                _bidToCollateral(finalCollateralAmount, exchangeRate),\n                poolId,\n                MODE.ADD\n            );\n        }\n    }\n\n    function _userPartiallyBidAmount(\n        Bidder memory entry,\n        uint256 collateralAmountToLiquidate,\n        uint256 exchangeRate,\n        uint256 poolId,\n        bytes memory swapData\n    )\n        private\n        returns (\n            uint256 finalDiscountedCollateralAmount,\n            uint256 finalUsdoAmount\n        )\n    {\n        finalUsdoAmount = 0;\n        finalDiscountedCollateralAmount = _getPremiumAmount(\n            _collateralToBid(collateralAmountToLiquidate, exchangeRate),\n            poolId,\n            MODE.SUB\n        );\n\n        //Execute the swap if USD0 was provided and it's different from the liqudation asset id\n        uint256 usdoAssetId = beachBar.usdoAssetId();\n        if (entry.swapOnExecute) {\n            finalUsdoAmount = liquidationQueueMeta\n                .bidExecutionSwapper\n                .getInputAmount(\n                    address(mixologist),\n                    usdoAssetId,\n                    finalDiscountedCollateralAmount,\n                    ''\n                );\n\n            yieldBox.transfer(\n                address(this),\n                address(liquidationQueueMeta.bidExecutionSwapper),\n                usdoAssetId,\n                yieldBox.toShare(usdoAssetId, finalUsdoAmount, false)\n            );\n            uint256 returnedCollateral = liquidationQueueMeta\n                .bidExecutionSwapper\n                .swap(\n                    address(mixologist),\n                    usdoAssetId,\n                    finalUsdoAmount,\n                    swapData\n                );\n            require(\n                returnedCollateral >= finalDiscountedCollateralAmount,\n                'need-more-collateral'\n            );\n        }\n    }\n\n    function _bid(\n        address user,\n        uint256 pool,\n        uint256 amount,\n        bool isUsdo\n    ) private returns (Bidder memory bidder) {\n        bidder.usdoAmount = isUsdo ? amount : 0;\n        bidder.liquidatedAssetAmount = isUsdo ? 0 : amount;\n        bidder.timestamp = block.timestamp;\n        bidder.isUsdo = isUsdo;\n        bidder.swapOnExecute = isUsdo && lqAssetId != beachBar.usdoAssetId();\n\n        bidPools[pool][user] = bidder;\n\n        emit Bid(\n            msg.sender,\n            user,\n            pool,\n            isUsdo ? amount : 0, //USD0 amount\n            isUsdo ? 0 : amount, //liquidated asset amount\n            block.timestamp\n        );\n\n        // Clean the userBidIndex.\n        uint256[] storage bidIndexes = userBidIndexes[user][pool];\n        uint256 bidIndexesLen = bidIndexes.length;\n        OrderBookPoolInfo memory poolInfo = orderBookInfos[pool];\n        for (uint256 i = 0; i < bidIndexesLen; ) {\n            if (bidIndexes[i] >= poolInfo.nextBidPull) {\n                bidIndexesLen = bidIndexes.length;\n                bidIndexes[i] = bidIndexes[bidIndexesLen - 1];\n                bidIndexes.pop();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Create an asset inside of BeachBar that will hold the funds.\n    function _registerAsset() internal returns (uint256) {\n        (, address contractAddress, , ) = yieldBox.assets(marketAssetId);\n        return\n            yieldBox.registerAsset(\n                TokenType.ERC20,\n                contractAddress,\n                IStrategy(address(0)),\n                0\n            );\n    }\n\n    /// @notice Called with `init`, setup the initial pool info values.\n    /// @param pool The targeted pool.\n    function _initOrderBookPoolInfo(uint256 pool) internal {\n        OrderBookPoolInfo memory poolInfo;\n        poolInfo.poolId = uint32(pool);\n        orderBookInfos[pool] = poolInfo;\n    }\n\n    /// @notice Get the discount gained from a bid in a `poolId` given a `amount`.\n    /// @param amount The amount of collateral to get the discount from.\n    /// @param poolId The targeted pool.\n    /// @param mode 0 subtract - 1 add.\n    function _getPremiumAmount(\n        uint256 amount,\n        uint256 poolId,\n        MODE mode\n    ) internal pure returns (uint256) {\n        uint256 premium = (amount * poolId * PREMIUM_FACTOR) /\n            PREMIUM_FACTOR_PRECISION;\n        return mode == MODE.ADD ? amount + premium : amount - premium;\n    }\n\n    /// @notice Convert a bid amount to a collateral amount.\n    /// @param amount The amount of bid to convert.\n    /// @param exchangeRate The exchange rate to use.\n    function _bidToCollateral(uint256 amount, uint256 exchangeRate)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (amount * exchangeRate) / EXCHANGE_RATE_PRECISION;\n    }\n\n    /// @notice Convert a collateral amount to a bid amount.\n    /// @param collateralAmount The amount of collateral to convert.\n    /// @param exchangeRate The exchange rate to use.\n    function _collateralToBid(uint256 collateralAmount, uint256 exchangeRate)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (collateralAmount * EXCHANGE_RATE_PRECISION) / exchangeRate;\n    }\n}\n"
    },
    "contracts/mocks/tests/FlashLoanMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\n\nimport '../../singularity/interfaces/IFlashLoan.sol';\nimport '../../singularity/interfaces/ISingularity.sol';\nimport '../../../yieldbox/contracts/interfaces/IYieldBox.sol';\n\ncontract FlashLoanMockAttacker is IFlashBorrower {\n    function onFlashLoan(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external {}\n}\n\ncontract FlashLoanMockSuccess is IFlashBorrower {\n    function onFlashLoan(\n        address,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata\n    ) external {\n        ISingularity mixologist = ISingularity(msg.sender);\n        IYieldBox yieldBox = IYieldBox(mixologist.yieldBox());\n\n        token.approve(address(yieldBox), amount + fee);\n\n        yieldBox.depositAsset(\n            mixologist.assetId(),\n            address(this),\n            msg.sender,\n            amount + fee,\n            0\n        );\n    }\n}\n"
    },
    "contracts/mocks/tests/VulnMultiSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../../BeachBar.sol';\n\ncontract VulnMultiSwapper {\n    function counterfeitSwap(\n        BeachBar beachbar,\n        uint256 assetId,\n        address target\n    ) public {\n        beachbar.yieldBox().withdraw(\n            assetId,\n            target,\n            msg.sender,\n            beachbar.yieldBox().amountOf(target, assetId),\n            0\n        );\n    }\n}\n"
    },
    "contracts/singularity/interfaces/IFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\n\n// solhint-disable max-line-length\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the `token` that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/singularity/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data)\n        external\n        returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data)\n        external\n        view\n        returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
    },
    "contracts/singularity/interfaces/ISendFrom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface ISendFrom {\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n}\n"
    },
    "contracts/singularity/interfaces/ISingularity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport './IOracle.sol';\r\nimport '../../IBeachBar.sol';\r\nimport '../../swappers/IMultiSwapper.sol';\r\n\r\ninterface ISingularity {\r\n    struct AccrueInfo {\r\n        uint64 interestPerSecond;\r\n        uint64 lastAccrued;\r\n        uint128 feesEarnedFraction;\r\n    }\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n    event LogAccrue(\r\n        uint256 accruedAmount,\r\n        uint256 feeFraction,\r\n        uint64 rate,\r\n        uint256 utilization\r\n    );\r\n    event LogAddAsset(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share,\r\n        uint256 fraction\r\n    );\r\n    event LogAddCollateral(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share\r\n    );\r\n    event LogBorrow(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        uint256 feeAmount,\r\n        uint256 part\r\n    );\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogRemoveAsset(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share,\r\n        uint256 fraction\r\n    );\r\n    event LogRemoveCollateral(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share\r\n    );\r\n    event LogRepay(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        uint256 part\r\n    );\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event LogFlashLoan(\r\n        address indexed borrower,\r\n        uint256 amount,\r\n        uint256 feeAmount,\r\n        address indexed receiver\r\n    );\r\n    event LogYieldBoxFeesDeposit(uint256 feeShares, uint256 tapAmount);\r\n    event LogApprovalForAll(\r\n        address indexed _from,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n    error NotApproved(address _from, address _operator);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function accrue() external;\r\n\r\n    function accrueInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint64 interestPerSecond,\r\n            uint64 lastBlockAccrued,\r\n            uint128 feesEarnedFraction\r\n        );\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function addAsset(\r\n        address from,\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) external returns (uint256 fraction);\r\n\r\n    function addCollateral(\r\n        address from,\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function allowance(address, address) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function asset() external view returns (address);\r\n\r\n    function assetId() external view returns (uint256);\r\n\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function beachBar() external view returns (address);\r\n\r\n    function borrow(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (uint256 part, uint256 share);\r\n\r\n    function claimOwnership() external;\r\n\r\n    function collateral() external view returns (address);\r\n\r\n    function collateralId() external view returns (uint256);\r\n\r\n    /// @notice Allows batched call to Singularity.\r\n    /// @param calls An array encoded call data.\r\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\r\n    function execute(bytes[] calldata calls, bool revertOnFail)\r\n        external\r\n        returns (bool[] memory successes, string[] memory results);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function exchangeRate() external view returns (uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function getInitData(\r\n        address collateral_,\r\n        address asset_,\r\n        IOracle oracle_,\r\n        bytes calldata oracleData_\r\n    ) external pure returns (bytes memory data);\r\n\r\n    function init(bytes calldata data) external payable;\r\n\r\n    function isSolvent(address user, bool open) external view returns (bool);\r\n\r\n    function liquidate(\r\n        address[] calldata users,\r\n        uint256[] calldata borrowParts,\r\n        address to,\r\n        IMultiSwapper swapper,\r\n        bool open\r\n    ) external;\r\n\r\n    function masterContract() external view returns (address);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function nonces(address) external view returns (uint256);\r\n\r\n    function oracle() external view returns (IOracle);\r\n\r\n    function oracleData() external view returns (bytes memory);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function pendingOwner() external view returns (address);\r\n\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function removeAsset(\r\n        address from,\r\n        address to,\r\n        uint256 fraction\r\n    ) external returns (uint256 share);\r\n\r\n    function removeCollateral(\r\n        address from,\r\n        address to,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function repay(\r\n        address from,\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) external returns (uint256 amount);\r\n\r\n    function setFeeTo(address newFeeTo) external;\r\n\r\n    function setSwapper(IMultiSwapper swapper, bool enable) external;\r\n\r\n    function swappers(IMultiSwapper) external view returns (bool);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalAsset() external view returns (uint128 elastic, uint128 base);\r\n\r\n    function totalBorrow()\r\n        external\r\n        view\r\n        returns (uint128 elastic, uint128 base);\r\n\r\n    function totalCollateralShare() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) external;\r\n\r\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\r\n\r\n    function userBorrowPart(address) external view returns (uint256);\r\n\r\n    function userCollateralShare(address) external view returns (uint256);\r\n\r\n    function withdrawFees() external;\r\n\r\n    function depositFeesToYieldBox(IMultiSwapper, IBeachBar.SwapData calldata)\r\n        external;\r\n\r\n    function yieldBox() external view returns (address payable);\r\n\r\n    function liquidationQueue() external view returns (address payable);\r\n\r\n    function withdrawTo(\r\n        uint16 dstChainId,\r\n        bytes memory receiver,\r\n        uint256 amount,\r\n        bytes calldata adapterParams,\r\n        address payable refundAddress\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/singularity/SGLCommon.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport './SGLStorage.sol';\r\n\r\nimport 'hardhat/console.sol';\r\n\r\ncontract SGLCommon is SGLStorage {\r\n    using RebaseLibrary for Rebase;\r\n\r\n    // ***************** //\r\n    // *** MODIFIERS *** //\r\n    // ***************** //\r\n    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.\r\n    /// If 'from' is msg.sender, it's allowed.\r\n    /// msg.sender can be an allowed operator if his allowance equal or exceed the balance of the user 'from'.\r\n    modifier allowed(address from) virtual {\r\n        if (\r\n            from != msg.sender && allowance[from][msg.sender] <= balanceOf[from]\r\n        ) {\r\n            revert NotApproved(from, msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\r\n    modifier solvent(address from) {\r\n        _;\r\n        require(_isSolvent(from, exchangeRate), 'SGL: insolvent');\r\n    }\r\n\r\n    bool private initialized;\r\n    modifier onlyOnce() {\r\n        require(!initialized, 'SGL: initialized');\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n\r\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\r\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\r\n    /// @return updated True if `exchangeRate` was updated.\r\n    /// @return rate The new exchange rate.\r\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\r\n        (updated, rate) = oracle.get(oracleData);\r\n\r\n        if (updated) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        } else {\r\n            // Return the old rate if fetching wasn't successful\r\n            rate = exchangeRate;\r\n        }\r\n    }\r\n\r\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\r\n    function accrue() public {\r\n        ISingularity.AccrueInfo memory _accrueInfo = accrueInfo;\r\n        // Number of seconds since accrue was called\r\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\r\n        if (elapsedTime == 0) {\r\n            return;\r\n        }\r\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        if (_totalBorrow.base == 0) {\r\n            // If there are no borrows, reset the interest rate\r\n            if (_accrueInfo.interestPerSecond != STARTING_INTEREST_PER_SECOND) {\r\n                _accrueInfo.interestPerSecond = STARTING_INTEREST_PER_SECOND;\r\n                emit LogAccrue(0, 0, STARTING_INTEREST_PER_SECOND, 0);\r\n            }\r\n            accrueInfo = _accrueInfo;\r\n            return;\r\n        }\r\n\r\n        uint256 extraAmount = 0;\r\n        uint256 feeFraction = 0;\r\n        Rebase memory _totalAsset = totalAsset;\r\n\r\n        // Accrue interest\r\n        extraAmount =\r\n            (uint256(_totalBorrow.elastic) *\r\n                _accrueInfo.interestPerSecond *\r\n                elapsedTime) /\r\n            1e18;\r\n        _totalBorrow.elastic += uint128(extraAmount);\r\n        uint256 fullAssetAmount = yieldBox.toAmount(\r\n            assetId,\r\n            _totalAsset.elastic,\r\n            false\r\n        ) + _totalBorrow.elastic;\r\n\r\n        uint256 feeAmount = (extraAmount * PROTOCOL_FEE) / PROTOCOL_FEE_DIVISOR; // % of interest paid goes to fee\r\n        feeFraction = (feeAmount * _totalAsset.base) / fullAssetAmount;\r\n        _accrueInfo.feesEarnedFraction += uint128(feeFraction);\r\n        totalAsset.base = _totalAsset.base + uint128(feeFraction);\r\n        totalBorrow = _totalBorrow;\r\n\r\n        // Update interest rate\r\n        uint256 utilization = (uint256(_totalBorrow.elastic) *\r\n            UTILIZATION_PRECISION) / fullAssetAmount;\r\n        if (utilization < MINIMUM_TARGET_UTILIZATION) {\r\n            uint256 underFactor = ((MINIMUM_TARGET_UTILIZATION - utilization) *\r\n                FACTOR_PRECISION) / MINIMUM_TARGET_UTILIZATION;\r\n            uint256 scale = INTEREST_ELASTICITY +\r\n                (underFactor * underFactor * elapsedTime);\r\n            _accrueInfo.interestPerSecond = uint64(\r\n                (uint256(_accrueInfo.interestPerSecond) * INTEREST_ELASTICITY) /\r\n                    scale\r\n            );\r\n\r\n            if (_accrueInfo.interestPerSecond < MINIMUM_INTEREST_PER_SECOND) {\r\n                _accrueInfo.interestPerSecond = MINIMUM_INTEREST_PER_SECOND; // 0.25% APR minimum\r\n            }\r\n        } else if (utilization > MAXIMUM_TARGET_UTILIZATION) {\r\n            uint256 overFactor = ((utilization - MAXIMUM_TARGET_UTILIZATION) *\r\n                FACTOR_PRECISION) / FULL_UTILIZATION_MINUS_MAX;\r\n            uint256 scale = INTEREST_ELASTICITY +\r\n                (overFactor * overFactor * elapsedTime);\r\n            uint256 newInterestPerSecond = (uint256(\r\n                _accrueInfo.interestPerSecond\r\n            ) * scale) / INTEREST_ELASTICITY;\r\n            if (newInterestPerSecond > MAXIMUM_INTEREST_PER_SECOND) {\r\n                newInterestPerSecond = MAXIMUM_INTEREST_PER_SECOND; // 1000% APR maximum\r\n            }\r\n            _accrueInfo.interestPerSecond = uint64(newInterestPerSecond);\r\n        }\r\n\r\n        emit LogAccrue(\r\n            extraAmount,\r\n            feeFraction,\r\n            _accrueInfo.interestPerSecond,\r\n            utilization\r\n        );\r\n        accrueInfo = _accrueInfo;\r\n    }\r\n\r\n    /// @notice Removes an asset from msg.sender and transfers it to `to`.\r\n    /// @param from Account to debit Assets from.\r\n    /// @param to The user that receives the removed assets.\r\n    /// @param fraction The amount/fraction of assets held to remove.\r\n    /// @return share The amount of shares transferred to `to`.\r\n    function removeAsset(\r\n        address from,\r\n        address to,\r\n        uint256 fraction\r\n    ) public allowed(from) returns (uint256 share) {\r\n        accrue();\r\n\r\n        share = _removeAsset(from, to, fraction, true);\r\n    }\r\n\r\n    /// @notice Adds assets to the lending pair.\r\n    /// @param from Address to add asset from.\r\n    /// @param to The address of the user to receive the assets.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\r\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\r\n    /// @param share The amount of shares to add.\r\n    /// @return fraction Total fractions added.\r\n    function addAsset(\r\n        address from,\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) public allowed(from) returns (uint256 fraction) {\r\n        accrue();\r\n        fraction = _addAsset(from, to, skim, share);\r\n    }\r\n\r\n    // ************************** //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\r\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\r\n    function _isSolvent(address user, uint256 _exchangeRate)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // accrue must have already been called!\r\n        uint256 borrowPart = userBorrowPart[user];\r\n        if (borrowPart == 0) return true;\r\n        uint256 collateralShare = userCollateralShare[user];\r\n        if (collateralShare == 0) return false;\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n\r\n        return\r\n            yieldBox.toAmount(\r\n                collateralId,\r\n                collateralShare *\r\n                    (EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION) *\r\n                    CLOSED_COLLATERIZATION_RATE,\r\n                false\r\n            ) >=\r\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\r\n            (borrowPart * _totalBorrow.elastic * _exchangeRate) /\r\n                _totalBorrow.base;\r\n    }\r\n\r\n    /// @dev Helper function to move tokens.\r\n    /// @param from Account to debit tokens from, in `yieldBox`.\r\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\r\n    /// @param share The amount in shares to add.\r\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\r\n    /// Only used for accounting checks.\r\n    /// @param skim If True, only does a balance check on this contract.\r\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\r\n    function _addTokens(\r\n        address from,\r\n        uint256 _assetId,\r\n        uint256 share,\r\n        uint256 total,\r\n        bool skim\r\n    ) internal {\r\n        _yieldBoxShares[from][_assetId] += share;\r\n\r\n        if (skim) {\r\n            require(\r\n                share <= yieldBox.balanceOf(address(this), _assetId) - total,\r\n                'SGL: too much'\r\n            );\r\n        } else {\r\n            yieldBox.transfer(from, address(this), _assetId, share); // added a 'from' instead of 'msg.sender' -0xGAB\r\n        }\r\n    }\r\n\r\n    /// @dev Concrete implementation of `addAsset`.\r\n    function _addAsset(\r\n        address from,\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) internal returns (uint256 fraction) {\r\n        Rebase memory _totalAsset = totalAsset;\r\n        uint256 totalAssetShare = _totalAsset.elastic;\r\n        uint256 allShare = _totalAsset.elastic +\r\n            yieldBox.toShare(assetId, totalBorrow.elastic, true);\r\n        fraction = allShare == 0\r\n            ? share\r\n            : (share * _totalAsset.base) / allShare;\r\n        if (_totalAsset.base + uint128(fraction) < 1000) {\r\n            return 0;\r\n        }\r\n        totalAsset = _totalAsset.add(share, fraction);\r\n        balanceOf[to] += fraction;\r\n        emit Transfer(address(0), to, fraction);\r\n\r\n        _addTokens(from, assetId, share, totalAssetShare, skim);\r\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `removeAsset`.\r\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\r\n    function _removeAsset(\r\n        address from,\r\n        address to,\r\n        uint256 fraction,\r\n        bool updateYieldBoxShares\r\n    ) internal returns (uint256 share) {\r\n        if (totalAsset.base == 0) {\r\n            return 0;\r\n        }\r\n        Rebase memory _totalAsset = totalAsset;\r\n        uint256 allShare = _totalAsset.elastic +\r\n            yieldBox.toShare(assetId, totalBorrow.elastic, true);\r\n        share = (fraction * allShare) / _totalAsset.base;\r\n        balanceOf[from] -= fraction;\r\n        emit Transfer(from, address(0), fraction);\r\n        _totalAsset.elastic -= uint128(share);\r\n        _totalAsset.base -= uint128(fraction);\r\n        require(_totalAsset.base >= 1000, 'SGL: min limit');\r\n        totalAsset = _totalAsset;\r\n        emit LogRemoveAsset(from, to, share, fraction);\r\n        yieldBox.transfer(address(this), to, assetId, share);\r\n        if (updateYieldBoxShares) {\r\n            _yieldBoxShares[from][assetId] -= share;\r\n        }\r\n    }\r\n\r\n    function _getCollateralAmountForShare(uint256 share)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return yieldBox.toAmount(collateralId, share, false);\r\n    }\r\n\r\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\r\n    function _getAmountForBorrowPart(uint256 borrowPart)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalBorrow.toElastic(borrowPart, false);\r\n    }\r\n\r\n    /// @dev Calculate the collateral shares that are needed for `borrowPart`,\r\n    /// taking the current exchange rate into account.\r\n    function _getCollateralSharesForBorrowPart(uint256 borrowPart)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 borrowAmount = totalBorrow.toElastic(borrowPart, false);\r\n        return\r\n            yieldBox.toShare(\r\n                collateralId,\r\n                (borrowAmount * LIQUIDATION_MULTIPLIER * exchangeRate) /\r\n                    (LIQUIDATION_MULTIPLIER_PRECISION *\r\n                        EXCHANGE_RATE_PRECISION),\r\n                false\r\n            );\r\n    }\r\n\r\n    /// @dev Compute the amount of `mixologist.assetId` from `fraction`\r\n    /// `fraction` can be `mixologist.accrueInfo.feeFraction` or `mixologist.balanceOf`\r\n    function _getAmountForAssetFraction(uint256 fraction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Rebase memory _totalAsset = totalAsset;\r\n        return\r\n            yieldBox.toAmount(\r\n                assetId,\r\n                (fraction * _totalAsset.elastic) / _totalAsset.base,\r\n                false\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/singularity/SGLLendingBorrowing.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport './SGLCommon.sol';\n\ncontract SGLLendingBorrowing is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public solvent(from) allowed(from) returns (uint256 part, uint256 share) {\n        accrue();\n\n        updateExchangeRate();\n\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool skim,\n        uint256 part\n    ) public allowed(from) returns (uint256 amount) {\n        accrue();\n\n        updateExchangeRate();\n\n        amount = _repay(from, to, skim, part);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 share\n    ) public allowed(from) {\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public solvent(from) allowed(from) {\n        // accrue must be called because we check solvency\n        accrue();\n\n        _removeCollateral(from, to, share);\n    }\n\n    /// @notice Flashloan ability.\n    /// @dev The contract expect the `borrower` to have at the end of `onFlashLoan` `amount` + the incurred fees.\n    /// The borrower is expected to `approve()` yieldBox for this number at the end of its `onFlashLoan()`.\n    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.\n    /// @param receiver Address of the token receiver.\n    /// @param amount of the tokens to receive.\n    /// @param data The calldata to pass to the `borrower` contract.\n    function flashLoan(\n        IFlashBorrower borrower,\n        address receiver,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 feeAmount = (amount * FLASHLOAN_FEE) / FLASHLOAN_FEE_PRECISION;\n        uint256 feeFraction = (yieldBox.toShare(assetId, feeAmount, false) *\n            _totalAsset.base) / _totalAsset.elastic;\n\n        yieldBox.withdraw(assetId, address(this), receiver, amount, 0);\n\n        borrower.onFlashLoan(msg.sender, asset, amount, feeAmount, data);\n        require(\n            yieldBox.amountOf(address(this), assetId) >= amount + feeAmount,\n            'SGL: insufficient funds'\n        );\n\n        totalAsset.base = _totalAsset.base + uint128(feeFraction);\n        accrueInfo.feesEarnedFraction += uint128(feeFraction);\n\n        emit LogFlashLoan(address(borrower), amount, feeAmount, receiver);\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n        _yieldBoxShares[from][collateralId] -= share;\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = (amount * BORROW_OPENING_FEE) /\n            BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        require(\n            totalBorrowCap == 0 || totalBorrow.base <= totalBorrowCap,\n            'SGL: borrow cap reached'\n        );\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        share = yieldBox.toShare(assetId, amount, false);\n        Rebase memory _totalAsset = totalAsset;\n        require(_totalAsset.base >= 1000, 'SGL: min limit');\n        _totalAsset.elastic -= uint128(share);\n        totalAsset = _totalAsset;\n\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address from,\n        address to,\n        bool skim,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 share = yieldBox.toShare(assetId, amount, true);\n        uint128 totalShare = totalAsset.elastic;\n        _addTokens(from, assetId, share, uint256(totalShare), skim);\n        totalAsset.elastic = totalShare + uint128(share);\n        emit LogRepay(skim ? address(yieldBox) : from, to, amount, part);\n    }\n}\n"
    },
    "contracts/singularity/SGLLiquidation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport './SGLCommon.sol';\n\n// solhint-disable max-line-length\n\ncontract SGLLiquidation is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n\n    /// @notice Return the amount of collateral for a `user` to be solvent. Returns 0 if user already solvent.\n    /// @dev We use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      To prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate The exchange rate asset/collateral.\n    /// @return The amount of collateral to be solvent.\n    function computeAssetAmountToSolvency(address user, uint256 _exchangeRate)\n        public\n        view\n        returns (uint256)\n    {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return 0;\n        uint256 collateralShare = userCollateralShare[user];\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = yieldBox.toAmount(\n            collateralId,\n            (collateralShare *\n                (EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION) *\n                LQ_COLLATERIZATION_RATE),\n            false\n        ) / _exchangeRate;\n        // Obviously it's not `borrowPart` anymore but `borrowAmount`\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        return\n            borrowPart >= collateralAmountInAsset\n                ? borrowPart - collateralAmountInAsset\n                : 0;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Entry point for liquidations.\n    /// @dev Will call `closedLiquidation()` if not LQ exists or no LQ bid avail exists. Otherwise use LQ.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param collateralToAssetSwapData Extra swap data\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param usdoToBorrowedSwapData Extra swap data\n    ///        Ignore for `closedLiquidation()`\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        IMultiSwapper swapper,\n        bytes calldata collateralToAssetSwapData,\n        bytes calldata usdoToBorrowedSwapData\n    ) external {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        accrue();\n\n        if (address(liquidationQueue) != address(0)) {\n            (, bool bidAvail) = liquidationQueue.getNextAvailBidPool();\n            if (bidAvail) {\n                _orderBookLiquidation(\n                    users,\n                    _exchangeRate,\n                    usdoToBorrowedSwapData\n                );\n                return;\n            }\n        }\n        _closedLiquidation(\n            users,\n            maxBorrowParts,\n            swapper,\n            _exchangeRate,\n            collateralToAssetSwapData\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _orderBookLiquidation(\n        address[] calldata users,\n        uint256 _exchangeRate,\n        bytes memory swapData\n    ) private {\n        uint256 allCollateralShare;\n        uint256 allBorrowAmount;\n        uint256 allBorrowPart;\n        Rebase memory _totalBorrow = totalBorrow;\n\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                uint256 borrowAmount = computeAssetAmountToSolvency(\n                    user,\n                    _exchangeRate\n                );\n                if (borrowAmount == 0) {\n                    continue;\n                }\n\n                uint256 borrowPart;\n                {\n                    uint256 availableBorrowPart = userBorrowPart[user];\n                    borrowPart = _totalBorrow.toBase(borrowAmount, false);\n                    userBorrowPart[user] = availableBorrowPart - borrowPart;\n                }\n                uint256 collateralShare = yieldBox.toShare(\n                    collateralId,\n                    (borrowAmount * _exchangeRate * LIQUIDATION_MULTIPLIER) /\n                        (EXCHANGE_RATE_PRECISION *\n                            LIQUIDATION_MULTIPLIER_PRECISION),\n                    false\n                );\n                userCollateralShare[user] -= collateralShare;\n                emit LogRemoveCollateral(\n                    user,\n                    address(liquidationQueue),\n                    collateralShare\n                );\n                emit LogRepay(\n                    address(liquidationQueue),\n                    user,\n                    borrowAmount,\n                    borrowPart\n                );\n\n                // Keep totals\n                allCollateralShare += collateralShare;\n                allBorrowAmount += borrowAmount;\n                allBorrowPart += borrowPart;\n            }\n        }\n        require(allBorrowAmount != 0, 'SGL: solvent');\n\n        _totalBorrow.elastic -= uint128(allBorrowAmount);\n        _totalBorrow.base -= uint128(allBorrowPart);\n        totalBorrow = _totalBorrow;\n        totalCollateralShare -= allCollateralShare;\n\n        uint256 allBorrowShare = yieldBox.toShare(\n            assetId,\n            allBorrowAmount,\n            true\n        );\n\n        // Transfer collateral to be liquidated\n        yieldBox.transfer(\n            address(this),\n            address(liquidationQueue),\n            collateralId,\n            allCollateralShare\n        );\n\n        // LiquidationQueue pay debt\n        liquidationQueue.executeBids(\n            yieldBox.toAmount(collateralId, allCollateralShare, true),\n            swapData\n        );\n\n        uint256 returnedShare = yieldBox.balanceOf(address(this), assetId) -\n            uint256(totalAsset.elastic);\n        uint256 extraShare = returnedShare - allBorrowShare;\n        uint256 callerShare = (extraShare * CALLER_FEE) / CALLER_FEE_DIVISOR; // 1% goes to caller\n\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n\n        totalAsset.elastic += uint128(returnedShare - callerShare);\n        emit LogAddAsset(\n            address(liquidationQueue),\n            address(this),\n            returnedShare - callerShare,\n            0\n        );\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param swapData Swap necessar data\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        IMultiSwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata swapData\n    ) private {\n        uint256 allCollateralShare;\n        uint256 allBorrowAmount;\n        uint256 allBorrowPart;\n        Rebase memory _totalBorrow = totalBorrow;\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                uint256 borrowPart;\n                {\n                    uint256 availableBorrowPart = userBorrowPart[user];\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart\n                        ? availableBorrowPart\n                        : maxBorrowParts[i];\n                    userBorrowPart[user] = availableBorrowPart - borrowPart;\n                }\n                uint256 borrowAmount = _totalBorrow.toElastic(\n                    borrowPart,\n                    false\n                );\n                uint256 collateralShare = yieldBox.toShare(\n                    collateralId,\n                    (borrowAmount * LIQUIDATION_MULTIPLIER * _exchangeRate) /\n                        (LIQUIDATION_MULTIPLIER_PRECISION *\n                            EXCHANGE_RATE_PRECISION),\n                    false\n                );\n                userCollateralShare[user] -= collateralShare;\n                emit LogRemoveCollateral(\n                    user,\n                    address(swapper),\n                    collateralShare\n                );\n                emit LogRepay(address(swapper), user, borrowAmount, borrowPart);\n\n                // Keep totals\n                allCollateralShare += collateralShare;\n                allBorrowAmount += borrowAmount;\n                allBorrowPart += borrowPart;\n            }\n        }\n        require(allBorrowAmount != 0, 'SGL: solvent');\n        _totalBorrow.elastic -= uint128(allBorrowAmount);\n        _totalBorrow.base -= uint128(allBorrowPart);\n        totalBorrow = _totalBorrow;\n        totalCollateralShare -= allCollateralShare;\n\n        uint256 allBorrowShare = yieldBox.toShare(\n            assetId,\n            allBorrowAmount,\n            true\n        );\n\n        // Closed liquidation using a pre-approved swapper\n        require(beachBar.swappers(swapper), 'SGL: Invalid swapper');\n\n        // Swaps the users collateral for the borrowed asset\n        yieldBox.transfer(\n            address(this),\n            address(swapper),\n            collateralId,\n            allCollateralShare\n        );\n\n        uint256 minAssetMount = 0;\n        if (swapData.length > 0) {\n            minAssetMount = abi.decode(swapData, (uint256));\n        }\n        swapper.swap(\n            collateralId,\n            assetId,\n            minAssetMount,\n            address(this),\n            collateralSwapPath,\n            allCollateralShare\n        );\n\n        uint256 returnedShare = yieldBox.balanceOf(address(this), assetId) -\n            uint256(totalAsset.elastic);\n        uint256 extraShare = returnedShare - allBorrowShare;\n        uint256 feeShare = (extraShare * PROTOCOL_FEE) / PROTOCOL_FEE_DIVISOR; // 10% of profit goes to fee.\n        uint256 callerShare = (extraShare * CALLER_FEE) / CALLER_FEE_DIVISOR; //  1%  of profit goes to caller.\n\n        yieldBox.transfer(address(this), beachBar.feeTo(), assetId, feeShare);\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n\n        totalAsset.elastic += uint128(returnedShare - feeShare - callerShare);\n        emit LogAddAsset(\n            address(swapper),\n            address(this),\n            extraShare - feeShare - callerShare,\n            0\n        );\n    }\n}\n"
    },
    "contracts/singularity/SGLStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/ERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol';\r\n\r\nimport '../../yieldbox/contracts/YieldBox.sol';\r\nimport '../swappers/IMultiSwapper.sol';\r\nimport '../singularity/interfaces/IOracle.sol';\r\nimport '../singularity/interfaces/IFlashLoan.sol';\r\nimport '../liquidationQueue/ILiquidationQueue.sol';\r\nimport '../IBeachBar.sol';\r\nimport './interfaces/ISingularity.sol';\r\n\r\n// solhint-disable max-line-length\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n\r\n*/\r\n\r\ncontract SGLStorage is BoringOwnable, ERC20 {\r\n    using RebaseLibrary for Rebase;\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n\r\n    ISingularity.AccrueInfo public accrueInfo;\r\n\r\n    IBeachBar public beachBar;\r\n    YieldBox public yieldBox;\r\n    ILiquidationQueue public liquidationQueue;\r\n    IERC20 public collateral;\r\n    IERC20 public asset;\r\n    uint256 public collateralId;\r\n    uint256 public assetId;\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralShare; // Total collateral supplied\r\n    Rebase public totalAsset; // elastic = yieldBox shares held by the Singularity, base = Total fractions held by asset suppliers\r\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\r\n    uint256 public totalBorrowCap;\r\n    mapping(address => mapping(uint256 => uint256)) internal _yieldBoxShares;\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralShare;\r\n    // userAssetFraction is called balanceOf for ERC20 compatibility (it's in ERC20.sol)\r\n    mapping(address => uint256) public userBorrowPart;\r\n    // map of operator approval\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /// @notice Exchange and interest rate tracking.\r\n    /// This is 'cached' here because calls to Oracles can be very expensive.\r\n    /// Asset -> collateral = assetAmount * exchangeRate.\r\n    uint256 public exchangeRate;\r\n\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n    address[] collateralSwapPath; // Collateral -> Asset\r\n    address[] tapSwapPath; // Asset -> Tap\r\n\r\n    //errors\r\n    error NotApproved(address _from, address _operator);\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(\r\n        uint256 accruedAmount,\r\n        uint256 feeFraction,\r\n        uint64 rate,\r\n        uint256 utilization\r\n    );\r\n    event LogAddCollateral(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share\r\n    );\r\n    event LogAddAsset(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share,\r\n        uint256 fraction\r\n    );\r\n    event LogRemoveCollateral(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share\r\n    );\r\n    event LogRemoveAsset(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 share,\r\n        uint256 fraction\r\n    );\r\n    event LogBorrow(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        uint256 feeAmount,\r\n        uint256 part\r\n    );\r\n    event LogRepay(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        uint256 part\r\n    );\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n    event LogFlashLoan(\r\n        address indexed borrower,\r\n        uint256 amount,\r\n        uint256 feeAmount,\r\n        address indexed receiver\r\n    );\r\n    event LogYieldBoxFeesDeposit(uint256 feeShares, uint256 tapAmount);\r\n    event LogApprovalForAll(\r\n        address indexed _from,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\r\n\r\n    // ***************** //\r\n    // *** CONSTANTS *** //\r\n    // ***************** //\r\n    uint256 internal constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\r\n    uint256 internal constant LQ_COLLATERIZATION_RATE = 25000; // 25%\r\n    uint256 internal constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\r\n    uint256 internal constant MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\r\n    uint256 internal constant MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\r\n    uint256 internal constant UTILIZATION_PRECISION = 1e18;\r\n    uint256 internal constant FULL_UTILIZATION = 1e18;\r\n    uint256 internal constant FULL_UTILIZATION_MINUS_MAX =\r\n        FULL_UTILIZATION - MAXIMUM_TARGET_UTILIZATION;\r\n    uint256 internal constant FACTOR_PRECISION = 1e18;\r\n\r\n    uint64 internal constant STARTING_INTEREST_PER_SECOND = 317097920; // approx 1% APR\r\n    uint64 internal constant MINIMUM_INTEREST_PER_SECOND = 79274480; // approx 0.25% APR\r\n    uint64 internal constant MAXIMUM_INTEREST_PER_SECOND = 317097920000; // approx 1000% APR\r\n    uint256 internal constant INTEREST_ELASTICITY = 28800e36; // Half or double in 28800 seconds (8 hours) if linear\r\n\r\n    uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;\r\n\r\n    uint256 internal constant ORDER_BOOK_LIQUIDATION_MULTIPLIER = 127000; // add 27%\r\n    uint256 internal constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\r\n    uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\r\n\r\n    // Fees\r\n    uint256 internal constant CALLER_FEE = 1000; // 1%\r\n    uint256 internal constant CALLER_FEE_DIVISOR = 1e5;\r\n    uint256 internal constant PROTOCOL_FEE = 10000; // 10%\r\n    uint256 internal constant PROTOCOL_FEE_DIVISOR = 1e5;\r\n    uint256 internal constant BORROW_OPENING_FEE = 50; // 0.05%\r\n    uint256 internal constant BORROW_OPENING_FEE_PRECISION = 1e5;\r\n    uint256 internal constant FLASHLOAN_FEE = 90; // 0.09%\r\n    uint256 internal constant FLASHLOAN_FEE_PRECISION = 1e5;\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    function symbol() public view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    'tm',\r\n                    collateral.safeSymbol(),\r\n                    '/',\r\n                    asset.safeSymbol(),\r\n                    '-',\r\n                    oracle.symbol(oracleData)\r\n                )\r\n            );\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    'Tapioca Singularity ',\r\n                    collateral.safeName(),\r\n                    '/',\r\n                    asset.safeName(),\r\n                    '-',\r\n                    oracle.name(oracleData)\r\n                )\r\n            );\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return asset.safeDecimals();\r\n    }\r\n\r\n    // totalSupply for ERC20 compatibility\r\n    // BalanceOf[user] represent a fraction\r\n    function totalSupply() public view override returns (uint256) {\r\n        return totalAsset.base;\r\n    }\r\n}\r\n"
    },
    "contracts/singularity/Singularity.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport './SGLCommon.sol';\nimport './SGLLiquidation.sol';\nimport './SGLLendingBorrowing.sol';\n\nimport '../singularity/interfaces/ISendFrom.sol';\n\nimport 'hardhat/console.sol';\n\n// solhint-disable max-line-length\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Tapioca market\ncontract Singularity is SGLCommon {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Base,\n        LendingBorrowing,\n        Liquidation\n    }\n    /// @notice returns the liquidation module\n    SGLLiquidation public liquidationModule;\n    /// @notice returns the lending module\n    SGLLendingBorrowing public lendingBorrowingModule;\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata data) external onlyOnce {\n        (\n            address _liquidationModule,\n            address _lendingBorrowingModule,\n            IBeachBar tapiocaBar_,\n            IERC20 _asset,\n            uint256 _assetId,\n            IERC20 _collateral,\n            uint256 _collateralId,\n            IOracle _oracle,\n            address[] memory _collateralSwapPath,\n            address[] memory _tapSwapPath\n        ) = abi.decode(\n                data,\n                (\n                    address,\n                    address,\n                    IBeachBar,\n                    IERC20,\n                    uint256,\n                    IERC20,\n                    uint256,\n                    IOracle,\n                    address[],\n                    address[]\n                )\n            );\n\n        liquidationModule = SGLLiquidation(_liquidationModule);\n        lendingBorrowingModule = SGLLendingBorrowing(_lendingBorrowingModule);\n        beachBar = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(beachBar);\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            'SGL: bad pair'\n        );\n        asset = _asset;\n        collateral = _collateral;\n        assetId = _assetId;\n        collateralId = _collateralId;\n        oracle = _oracle;\n        collateralSwapPath = _collateralSwapPath;\n        tapSwapPath = _tapSwapPath;\n\n        accrueInfo.interestPerSecond = uint64(STARTING_INTEREST_PER_SECOND); // 1% APR, with 1e18 being 100%\n\n        updateExchangeRate();\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns Total yieldBox shares for user\n    /// @param _user The user to check shares for\n    /// @param _assetId The asset id to check shares for\n    function yieldBoxShares(address _user, uint256 _assetId)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            yieldBox.balanceOf(_user, _assetId) +\n            _yieldBoxShares[_user][_assetId];\n    }\n\n    /// @notice Return the amount of collateral for a `user` to be solvent. Returns 0 if user already solvent.\n    /// @dev We use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      To prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate The exchange rate asset/collateral.\n    /// @return amountToSolvency The amount of collateral to be solvent.\n    function computeAssetAmountToSolvency(address user, uint256 _exchangeRate)\n        public\n        view\n        returns (uint256 amountToSolvency)\n    {\n        bytes memory result = _executeViewModule(\n            Module.Liquidation,\n            abi.encodeWithSelector(\n                SGLLiquidation.computeAssetAmountToSolvency.selector,\n                user,\n                _exchangeRate\n            )\n        );\n        amountToSolvency = abi.decode(result, (uint256));\n    }\n\n    /// @notice Calculate the collateral amount off the shares.\n    /// @param share The shares.\n    /// @return amount The amount.\n    function getCollateralAmountForShare(uint256 share)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return _getCollateralAmountForShare(share);\n    }\n\n    /// @notice Calculate the collateral shares that are needed for `borrowPart`,\n    /// taking the current exchange rate into account.\n    /// @param borrowPart The borrow part.\n    /// @return collateralShares The collateral shares.\n    function getCollateralSharesForBorrowPart(uint256 borrowPart)\n        public\n        view\n        returns (uint256 collateralShares)\n    {\n        return _getCollateralSharesForBorrowPart(borrowPart);\n    }\n\n    /// @notice Compute the amount of `mixologist.assetId` from `fraction`\n    /// `fraction` can be `mixologist.accrueInfo.feeFraction` or `mixologist.balanceOf`\n    /// @param fraction The fraction.\n    /// @return amount The amount.\n    function getAmountForAssetFraction(uint256 fraction)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return _getAmountForAssetFraction(fraction);\n    }\n\n    /// @notice Return the equivalent of borrow part in asset amount.\n    /// @param borrowPart The amount of borrow part to convert.\n    /// @return amount The equivalent of borrow part in asset amount.\n    function getAmountForBorrowPart(uint256 borrowPart)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return _getAmountForBorrowPart(borrowPart);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Allows batched call to Singularity.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(bytes[] calldata calls, bool revertOnFail)\n        external\n        returns (bool[] memory successes, string[] memory results)\n    {\n        successes = new bool[](calls.length);\n        results = new string[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = _getRevertMsg(result);\n        }\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 share\n    ) public {\n        _executeModule(\n            Module.LendingBorrowing,\n            abi.encodeWithSelector(\n                SGLLendingBorrowing.addCollateral.selector,\n                from,\n                to,\n                skim,\n                share\n            )\n        );\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public {\n        _executeModule(\n            Module.LendingBorrowing,\n            abi.encodeWithSelector(\n                SGLLendingBorrowing.removeCollateral.selector,\n                from,\n                to,\n                share\n            )\n        );\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (uint256 part, uint256 share) {\n        bytes memory result = _executeModule(\n            Module.LendingBorrowing,\n            abi.encodeWithSelector(\n                SGLLendingBorrowing.borrow.selector,\n                from,\n                to,\n                amount\n            )\n        );\n        (part, share) = abi.decode(result, (uint256, uint256));\n    }\n\n    /// @notice Repays a loan.\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        bool skim,\n        uint256 part\n    ) public returns (uint256 amount) {\n        bytes memory result = _executeModule(\n            Module.LendingBorrowing,\n            abi.encodeWithSelector(\n                SGLLendingBorrowing.repay.selector,\n                from,\n                to,\n                skim,\n                part\n            )\n        );\n        amount = abi.decode(result, (uint256));\n    }\n\n    /// @notice Entry point for liquidations.\n    /// @dev Will call `closedLiquidation()` if not LQ exists or no LQ bid avail exists. Otherwise use LQ.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param collateralToAssetSwapData Extra swap data\n    ///        Ignore for `orderBookLiquidation()`\n    /// @param usdoToBorrowedSwapData Extra swap data\n    ///        Ignore for `closedLiquidation()`\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        IMultiSwapper swapper,\n        bytes calldata collateralToAssetSwapData,\n        bytes calldata usdoToBorrowedSwapData\n    ) external {\n        _executeModule(\n            Module.Liquidation,\n            abi.encodeWithSelector(\n                SGLLiquidation.liquidate.selector,\n                users,\n                maxBorrowParts,\n                swapper,\n                collateralToAssetSwapData,\n                usdoToBorrowedSwapData\n            )\n        );\n    }\n\n    /// @notice Flashloan ability.\n    /// @dev The contract expect the `borrower` to have at the end of `onFlashLoan` `amount` + the incurred fees.\n    /// The borrower is expected to `approve()` yieldBox for this number at the end of its `onFlashLoan()`.\n    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.\n    /// @param receiver Address of the token receiver.\n    /// @param amount of the tokens to receive.\n    /// @param data The calldata to pass to the `borrower` contract.\n    function flashLoan(\n        IFlashBorrower borrower,\n        address receiver,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        _executeModule(\n            Module.LendingBorrowing,\n            abi.encodeWithSelector(\n                SGLLendingBorrowing.flashLoan.selector,\n                borrower,\n                receiver,\n                amount,\n                data\n            )\n        );\n    }\n\n    /// @notice Withdraw the fees accumulated in `accrueInfo.feesEarnedFraction` to the balance of `feeTo`.\n    function withdrawFeesEarned() public {\n        accrue();\n        address _feeTo = beachBar.feeTo();\n        uint256 _feesEarnedFraction = accrueInfo.feesEarnedFraction;\n        balanceOf[_feeTo] += _feesEarnedFraction;\n        emit Transfer(address(0), _feeTo, _feesEarnedFraction);\n        accrueInfo.feesEarnedFraction = 0;\n        emit LogWithdrawFees(_feeTo, _feesEarnedFraction);\n    }\n\n    /// @notice Withdraw the balance of `feeTo`, swap asset into TAP and deposit it to yieldBox of `feeTo`\n    function depositFeesToYieldBox(\n        IMultiSwapper swapper,\n        IBeachBar.SwapData calldata swapData\n    ) public {\n        if (accrueInfo.feesEarnedFraction > 0) {\n            withdrawFeesEarned();\n        }\n        require(beachBar.swappers(swapper), 'Mx: Invalid swapper');\n        address _feeTo = beachBar.feeTo();\n        address _feeVeTap = beachBar.feeVeTap();\n\n        uint256 feeShares = _removeAsset(\n            _feeTo,\n            address(this),\n            balanceOf[_feeTo],\n            false\n        );\n        if (feeShares == 0) return;\n\n        yieldBox.transfer(address(this), address(swapper), assetId, feeShares);\n\n        (uint256 tapAmount, ) = swapper.swap(\n            assetId,\n            beachBar.tapAssetId(),\n            swapData.minAssetAmount,\n            _feeVeTap,\n            tapSwapPath,\n            feeShares\n        );\n\n        emit LogYieldBoxFeesDeposit(feeShares, tapAmount);\n    }\n\n    /// @notice Withdraw to another layer\n    function withdrawTo(\n        uint16 dstChainId,\n        bytes memory receiver,\n        uint256 amount,\n        bytes calldata adapterParams,\n        address payable refundAddress\n    ) public payable {\n        try\n            IERC165(address(asset)).supportsInterface(\n                type(ISendFrom).interfaceId\n            )\n        {} catch {\n            return;\n        }\n\n        uint256 available = yieldBox.toAmount(\n            assetId,\n            yieldBox.balanceOf(msg.sender, assetId),\n            false\n        );\n        require(available >= amount, 'SGL: not available');\n\n        yieldBox.withdraw(assetId, msg.sender, address(this), amount, 0);\n        ISendFrom(address(asset)).sendFrom{value: msg.value}(\n            address(this),\n            dstChainId,\n            receiver,\n            amount,\n            refundAddress,\n            msg.sender,\n            adapterParams\n        );\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Used to set the swap path of closed liquidations\n    /// @param _collateralSwapPath The Uniswap path .\n    function setCollateralSwapPath(address[] calldata _collateralSwapPath)\n        public\n        onlyOwner\n    {\n        collateralSwapPath = _collateralSwapPath;\n    }\n\n    /// @notice Used to set the swap path of Asset -> TAP\n    /// @param _tapSwapPath The Uniswap path .\n    function setTapSwapPath(address[] calldata _tapSwapPath) public onlyOwner {\n        tapSwapPath = _tapSwapPath;\n    }\n\n    /// @notice Set a new LiquidationQueue.\n    /// @param _liquidationQueue The address of the new LiquidationQueue contract.\n    function setLiquidationQueue(ILiquidationQueue _liquidationQueue)\n        public\n        onlyOwner\n    {\n        require(_liquidationQueue.onlyOnce(), 'SGL: LQ not initalized');\n        liquidationQueue = _liquidationQueue;\n    }\n\n    /// @notice Execute an only owner function inside of the LiquidationQueue\n    function updateLQExecutionSwapper(address _swapper) external onlyOwner {\n        liquidationQueue.setBidExecutionSwapper(_swapper);\n    }\n\n    /// @notice Execute an only owner function inside of the LiquidationQueue\n    function updateLQUsdoSwapper(address _swapper) external onlyOwner {\n        liquidationQueue.setUsdoSwapper(_swapper);\n    }\n\n    /// @notice sets max borrowable amount\n    function setBorrowCap(uint256 _cap) external onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getRevertMsg(bytes memory _returnData)\n        private\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return 'SGL: no return data';\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _executeModule(Module _module, bytes memory _data)\n        private\n        returns (bytes memory returnData)\n    {\n        address module;\n        bool success = true;\n\n        if (_module == Module.LendingBorrowing) {\n            module = address(lendingBorrowingModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        }\n\n        if (module == address(0)) {\n            revert('SGL: module not set');\n        }\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeViewModule(Module _module, bytes memory _data)\n        private\n        view\n        returns (bytes memory returnData)\n    {\n        address module;\n        bool success = true;\n\n        if (_module == Module.LendingBorrowing) {\n            module = address(lendingBorrowingModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        }\n\n        if (module == address(0)) {\n            revert('SGL: module not set');\n        }\n\n        (success, returnData) = module.staticcall(_data);\n        if (!success) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n}\n"
    },
    "contracts/singularity/SingularityHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/ERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol';\r\n\r\nimport './interfaces/ISingularity.sol';\r\nimport '../../yieldbox/contracts/YieldBox.sol';\r\n\r\n/// @title Useful helper functions for `Singularity`.\r\ncontract SingularityHelper {\r\n    using RebaseLibrary for Rebase;\r\n\r\n    struct MarketInfo {\r\n        address collateral;\r\n        address asset;\r\n        IOracle oracle;\r\n        bytes oracleData;\r\n        uint256 totalCollateralShare;\r\n        uint256 userCollateralShare;\r\n        Rebase totalAsset;\r\n        uint256 userAssetFraction;\r\n        Rebase totalBorrow;\r\n        uint256 userBorrowPart;\r\n        uint256 currentExchangeRate;\r\n        uint256 spotExchangeRate;\r\n        uint256 oracleExchangeRate;\r\n        ISingularity.AccrueInfo accrueInfo;\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    function marketsInfo(address who, ISingularity[] memory markets)\r\n        external\r\n        view\r\n        returns (MarketInfo[] memory)\r\n    {\r\n        uint256 len = markets.length;\r\n        MarketInfo[] memory result = new MarketInfo[](len);\r\n\r\n        Rebase memory _totalAsset;\r\n        Rebase memory _totalBorrowed;\r\n        ISingularity.AccrueInfo memory _accrueInfo;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            ISingularity sgl = markets[i];\r\n\r\n            result[i].collateral = sgl.collateral();\r\n            result[i].asset = sgl.asset();\r\n            result[i].oracle = sgl.oracle();\r\n            result[i].oracleData = sgl.oracleData();\r\n            result[i].totalCollateralShare = sgl.totalCollateralShare();\r\n            result[i].userCollateralShare = sgl.userCollateralShare(who);\r\n            (uint128 totalAssetElastic, uint128 totalAssetBase) = sgl\r\n                .totalAsset();\r\n            _totalAsset = Rebase(totalAssetElastic, totalAssetBase);\r\n            result[i].totalAsset = _totalAsset;\r\n            result[i].userAssetFraction = sgl.balanceOf(who);\r\n            (uint128 totalBorrowElastic, uint128 totalBorrowBase) = sgl\r\n                .totalBorrow();\r\n            _totalBorrowed = Rebase(totalBorrowElastic, totalBorrowBase);\r\n            result[i].totalBorrow = _totalBorrowed;\r\n            result[i].userBorrowPart = sgl.userBorrowPart(who);\r\n\r\n            result[i].currentExchangeRate = sgl.exchangeRate();\r\n            (, result[i].oracleExchangeRate) = sgl.oracle().peek(\r\n                sgl.oracleData()\r\n            );\r\n            result[i].spotExchangeRate = sgl.oracle().peekSpot(\r\n                sgl.oracleData()\r\n            );\r\n            (\r\n                uint64 interestPerSecond,\r\n                uint64 lastBlockAccrued,\r\n                uint128 feesEarnedFraction\r\n            ) = sgl.accrueInfo();\r\n            _accrueInfo = ISingularity.AccrueInfo(\r\n                interestPerSecond,\r\n                lastBlockAccrued,\r\n                feesEarnedFraction\r\n            );\r\n            result[i].accrueInfo = _accrueInfo;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n\r\n    /// @notice deposits asset to YieldBox and lends it to Singularity\r\n    /// @param mixologist the mixologist address\r\n    /// @param _amount the amount to lend\r\n    function depositAndAddAsset(ISingularity mixologist, uint256 _amount)\r\n        external\r\n    {\r\n        uint256 assetId = mixologist.assetId();\r\n        YieldBox yieldBox = YieldBox(mixologist.yieldBox());\r\n\r\n        (, address assetAddress, , ) = yieldBox.assets(assetId);\r\n        _extractTokens(assetAddress, _amount);\r\n\r\n        //deposit into the yieldbox\r\n        uint256 _share = yieldBox.toShare(assetId, _amount, false);\r\n        IERC20(assetAddress).approve(address(yieldBox), _amount);\r\n        yieldBox.depositAsset(assetId, address(this), address(this), 0, _share);\r\n\r\n        //add asset\r\n        _setApprovalForYieldBox(mixologist, yieldBox);\r\n        mixologist.addAsset(address(this), msg.sender, false, _share);\r\n    }\r\n\r\n    /// @notice deposts collateral to YieldBox, adds collateral to Singularity, borrows and can withdraw to personal address\r\n    /// @param mixologist the mixologist address\r\n    /// @param _collateralAmount the collateral amount to add\r\n    /// @param _borrowAmount the amount to borrow\r\n    /// @param withdraw_ if true, withdraws from YieldBox to `msg.sender`\r\n    /// @param _withdrawData custom withdraw data; ignore if you need to withdraw on the same chain\r\n    function depositAddCollateralAndBorrow(\r\n        ISingularity mixologist,\r\n        uint256 _collateralAmount,\r\n        uint256 _borrowAmount,\r\n        bool withdraw_,\r\n        bytes calldata _withdrawData\r\n    ) external payable {\r\n        YieldBox yieldBox = YieldBox(mixologist.yieldBox());\r\n\r\n        uint256 collateralId = mixologist.collateralId();\r\n\r\n        (, address collateralAddress, , ) = yieldBox.assets(collateralId);\r\n        _extractTokens(collateralAddress, _collateralAmount);\r\n\r\n        //deposit into the yieldbox\r\n        uint256 _share = yieldBox.toShare(\r\n            collateralId,\r\n            _collateralAmount,\r\n            false\r\n        );\r\n        IERC20(collateralAddress).approve(address(yieldBox), _collateralAmount);\r\n        yieldBox.depositAsset(\r\n            collateralId,\r\n            address(this),\r\n            address(this),\r\n            0,\r\n            _share\r\n        );\r\n\r\n        //add collateral\r\n        _setApprovalForYieldBox(mixologist, yieldBox);\r\n        mixologist.addCollateral(address(this), msg.sender, false, _share);\r\n\r\n        //borrow\r\n        address borrowReceiver = withdraw_ ? address(this) : msg.sender;\r\n        mixologist.borrow(msg.sender, borrowReceiver, _borrowAmount);\r\n\r\n        if (withdraw_) {\r\n            _withdraw(_withdrawData, mixologist, yieldBox, _borrowAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice deposits to YieldBox and repays borrowed amount\r\n    /// @param mixologist the mixologist address\r\n    /// @param _depositAmount the amount to deposit\r\n    /// @param _repayAmount the amount to be repayed\r\n    function depositAndRepay(\r\n        ISingularity mixologist,\r\n        uint256 _depositAmount,\r\n        uint256 _repayAmount\r\n    ) public {\r\n        uint256 assetId = mixologist.assetId();\r\n        YieldBox yieldBox = YieldBox(mixologist.yieldBox());\r\n\r\n        (, address assetAddress, , ) = yieldBox.assets(assetId);\r\n        _extractTokens(assetAddress, _depositAmount);\r\n\r\n        //deposit into the yieldbox\r\n        IERC20(assetAddress).approve(address(yieldBox), _depositAmount);\r\n        yieldBox.depositAsset(\r\n            assetId,\r\n            address(this),\r\n            address(this),\r\n            _depositAmount,\r\n            0\r\n        );\r\n\r\n        //repay\r\n        _setApprovalForYieldBox(mixologist, yieldBox);\r\n        mixologist.repay(address(this), msg.sender, false, _repayAmount);\r\n    }\r\n\r\n    /// @notice deposits to YieldBox, repays borrowed amount and removes collateral\r\n    /// @param mixologist the mixologist address\r\n    /// @param _depositAmount the amount to deposit\r\n    /// @param _repayAmount the amount to be repayed\r\n    /// @param _collateralAmount collateral amount to be removed\r\n    /// @param withdraw_ if true withdraws to sender address\r\n    function depositRepayAndRemoveCollateral(\r\n        ISingularity mixologist,\r\n        uint256 _depositAmount,\r\n        uint256 _repayAmount,\r\n        uint256 _collateralAmount,\r\n        bool withdraw_\r\n    ) external {\r\n        YieldBox yieldBox = YieldBox(mixologist.yieldBox());\r\n\r\n        depositAndRepay(mixologist, _depositAmount, _repayAmount);\r\n\r\n        //remove collateral\r\n        address receiver = withdraw_ ? address(this) : msg.sender;\r\n        uint256 collateralShare = yieldBox.toShare(\r\n            mixologist.collateralId(),\r\n            _collateralAmount,\r\n            false\r\n        );\r\n        mixologist.removeCollateral(msg.sender, receiver, collateralShare);\r\n\r\n        //withdraw\r\n        if (withdraw_) {\r\n            yieldBox.withdraw(\r\n                mixologist.collateralId(),\r\n                address(this),\r\n                msg.sender,\r\n                _collateralAmount,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n    // ************************** //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    function _withdraw(\r\n        bytes calldata _withdrawData,\r\n        ISingularity mixologist,\r\n        YieldBox yieldBox,\r\n        uint256 _amount\r\n    ) private {\r\n        bool _otherChain;\r\n        uint16 _destChain;\r\n        bytes memory _receiver;\r\n        bytes memory _adapterParams;\r\n        if (_withdrawData.length > 0) {\r\n            (_otherChain, _destChain, _receiver, _adapterParams) = abi.decode(\r\n                _withdrawData,\r\n                (bool, uint16, bytes, bytes)\r\n            );\r\n        }\r\n        if (!_otherChain) {\r\n            yieldBox.withdraw(\r\n                mixologist.assetId(),\r\n                address(this),\r\n                msg.sender,\r\n                _amount,\r\n                0\r\n            );\r\n            return;\r\n        }\r\n\r\n        mixologist.withdrawTo{value: msg.value}(\r\n            _destChain,\r\n            _receiver,\r\n            _amount,\r\n            _adapterParams,\r\n            payable(msg.sender)\r\n        );\r\n    }\r\n\r\n    function _setApprovalForYieldBox(ISingularity mixologist, YieldBox yieldBox)\r\n        private\r\n    {\r\n        bool isApproved = yieldBox.isApprovedForAll(\r\n            address(this),\r\n            address(mixologist)\r\n        );\r\n        if (!isApproved) {\r\n            yieldBox.setApprovalForAll(address(mixologist), true);\r\n        }\r\n        isApproved = yieldBox.isApprovedForAll(\r\n            address(this),\r\n            address(mixologist)\r\n        );\r\n    }\r\n\r\n    function _extractTokens(address _token, uint256 _amount) private {\r\n        require(\r\n            ERC20(_token).transferFrom(msg.sender, address(this), _amount),\r\n            'transfer failed'\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/aave/AaveStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../../../yieldbox/contracts/strategies/BaseStrategy.sol';\r\nimport '../../swappers/NonYieldBoxMultiSwapper.sol';\r\n\r\nimport './ILendingPool.sol';\r\nimport './IIncentivesController.sol';\r\nimport './IStkAave.sol';\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n*/\r\n\r\n//Wrapped-native strategy for AAVE\r\ncontract AaveStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    IERC20 public immutable wrappedNative;\r\n    NonYieldBoxMultiSwapper public swapper;\r\n\r\n    //AAVE\r\n    IStkAave public immutable stakedRewardToken;\r\n    IERC20 public immutable rewardToken;\r\n    IERC20 public immutable receiptToken;\r\n    ILendingPool public immutable lendingPool;\r\n    IIncentivesController public immutable incentivesController;\r\n\r\n    /// @notice Queues tokens up to depositThreshold\r\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\r\n    uint256 public depositThreshold;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event MultiSwapper(address indexed _old, address indexed _new);\r\n    event DepositThreshold(uint256 _old, uint256 _new);\r\n    event AmountQueued(uint256 amount);\r\n    event AmountDeposited(uint256 amount);\r\n    event AmountWithdrawn(address indexed to, uint256 amount);\r\n\r\n    // 0x7d2768de32b0b80b7a3454c06bdac94a69ddc7a9; aave lending pool ETH\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _token,\r\n        address _lendingPool,\r\n        address _incentivesController,\r\n        address _receiptToken,\r\n        address _multiSwapper\r\n    ) BaseERC20Strategy(_yieldBox, _token) {\r\n        wrappedNative = IERC20(_token);\r\n        swapper = NonYieldBoxMultiSwapper(_multiSwapper);\r\n\r\n        lendingPool = ILendingPool(_lendingPool);\r\n        incentivesController = IIncentivesController(_incentivesController);\r\n        stakedRewardToken = IStkAave(incentivesController.REWARD_TOKEN());\r\n        rewardToken = IERC20(stakedRewardToken.REWARD_TOKEN());\r\n        receiptToken = IERC20(_receiptToken);\r\n\r\n        wrappedNative.approve(_lendingPool, type(uint256).max);\r\n        rewardToken.approve(_multiSwapper, type(uint256).max);\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    /// @notice Returns the name of this strategy\r\n    function name() external pure override returns (string memory name_) {\r\n        return 'AAVE';\r\n    }\r\n\r\n    /// @notice Returns the description of this strategy\r\n    function description()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory description_)\r\n    {\r\n        return 'AAVE strategy for wrapped native assets';\r\n    }\r\n\r\n    /// @notice returns compounded amounts in wrappedNative\r\n    function compoundAmount() public view returns (uint256 result) {\r\n        uint256 claimable = stakedRewardToken.stakerRewardsToClaim(\r\n            address(this)\r\n        );\r\n        result = 0;\r\n        if (claimable > 0) {\r\n            address[] memory path = new address[](2); //todo: check if path is right\r\n            path[0] = address(rewardToken);\r\n            path[1] = address(wrappedNative);\r\n            result = swapper.getOutputAmount(path, claimable);\r\n        }\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n    /// @notice Sets the deposit threshold\r\n    /// @param amount The new threshold amount\r\n    function setDepositThreshold(uint256 amount) external onlyOwner {\r\n        emit DepositThreshold(depositThreshold, amount);\r\n        depositThreshold = amount;\r\n    }\r\n\r\n    /// @notice Sets the Swapper address\r\n    /// @param _swapper The new swapper address\r\n    function setMultiSwapper(address _swapper) external onlyOwner {\r\n        emit MultiSwapper(address(swapper), _swapper);\r\n        swapper = NonYieldBoxMultiSwapper(_swapper);\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function compound(bool _tryStake) public {\r\n        uint256 aaveBalanceBefore = rewardToken.balanceOf(address(this));\r\n        //first claim stkAave\r\n        uint256 unclaimedStkAave = incentivesController.getUserUnclaimedRewards(\r\n            address(this)\r\n        );\r\n\r\n        if (unclaimedStkAave > 0) {\r\n            address[] memory tokens = new address[](1);\r\n            tokens[0] = address(receiptToken);\r\n            incentivesController.claimRewards(\r\n                tokens,\r\n                type(uint256).max,\r\n                address(this)\r\n            );\r\n        }\r\n        //try to claim AAVE\r\n        uint256 claimable = stakedRewardToken.stakerRewardsToClaim(\r\n            address(this)\r\n        );\r\n        if (claimable > 0) {\r\n            stakedRewardToken.claimRewards(address(this), claimable);\r\n        }\r\n\r\n        //try to cooldown\r\n        uint256 currentCooldown = stakedRewardToken.stakersCooldowns(\r\n            address(this)\r\n        );\r\n        if (currentCooldown > 0) {\r\n            //we have an active cooldown; check if we need to cooldown again\r\n            bool daysPassed = (currentCooldown + 12 days) < block.timestamp;\r\n            if (daysPassed) {\r\n                stakedRewardToken.cooldown();\r\n            }\r\n        } else {\r\n            stakedRewardToken.cooldown();\r\n        }\r\n\r\n        //try to stake\r\n        uint256 aaveBalanceAfter = rewardToken.balanceOf(address(this));\r\n        if (aaveBalanceAfter > aaveBalanceBefore) {\r\n            uint256 aaveAmount = aaveBalanceAfter - aaveBalanceBefore;\r\n\r\n            //swap AAVE to wrappedNative\r\n            address[] memory path = new address[](2); //todo: check if path is right\r\n            path[0] = address(rewardToken);\r\n            path[1] = address(wrappedNative);\r\n            uint256 calcAmount = swapper.getOutputAmount(path, aaveAmount);\r\n            uint256 minAmount = (calcAmount * 2_500) / 10_000; //2.5%\r\n            swapper.swap(\r\n                address(rewardToken),\r\n                address(wrappedNative),\r\n                minAmount,\r\n                address(this),\r\n                path,\r\n                aaveAmount\r\n            );\r\n\r\n            //stake if > depositThreshold\r\n            uint256 queued = wrappedNative.balanceOf(address(this));\r\n            if (_tryStake && queued > depositThreshold) {\r\n                lendingPool.deposit(\r\n                    address(wrappedNative),\r\n                    queued,\r\n                    address(this),\r\n                    0\r\n                );\r\n                emit AmountDeposited(queued);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    /// @dev queries 'getUserAccountData' from AAVE and gets the total collateral\r\n    function _currentBalance() internal view override returns (uint256 amount) {\r\n        (amount, , , , , ) = lendingPool.getUserAccountData(address(this));\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        uint256 claimableRewards = compoundAmount();\r\n        return amount + queued + claimableRewards;\r\n    }\r\n\r\n    /// @dev deposits to AAVE or queues tokens if the 'depositThreshold' has not been met yet\r\n    ///      - when depositing to AAVE, aToken is minted to this contract\r\n    function _deposited(uint256 amount) internal override nonReentrant {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > depositThreshold) {\r\n            lendingPool.deposit(\r\n                address(wrappedNative),\r\n                queued,\r\n                address(this),\r\n                0\r\n            );\r\n            emit AmountDeposited(queued);\r\n            return;\r\n        }\r\n        emit AmountQueued(amount);\r\n    }\r\n\r\n    /// @dev burns aToken in exchange of Token and withdraws from AAVE LendingPool\r\n    function _withdraw(address to, uint256 amount)\r\n        internal\r\n        override\r\n        nonReentrant\r\n    {\r\n        uint256 available = _currentBalance();\r\n        require(available >= amount, 'AaveStrategy: amount not valid');\r\n\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (amount > queued) {\r\n            compound(false);\r\n\r\n            uint256 toWithdraw = amount - queued;\r\n\r\n            uint256 obtainedWrapped = lendingPool.withdraw(\r\n                address(wrappedNative),\r\n                toWithdraw,\r\n                address(this)\r\n            );\r\n            if (obtainedWrapped > toWithdraw) {\r\n                amount += (obtainedWrapped - toWithdraw);\r\n            }\r\n        }\r\n\r\n        wrappedNative.safeTransfer(to, amount);\r\n        emit AmountWithdrawn(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/aave/IIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IIncentivesController {\r\n    /**\r\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev for backward compatibility with previous implementation of the Incentives controller\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function REWARD_TOKEN() external view returns (address);\r\n\r\n    /**\r\n     * @dev returns the unclaimed rewards of the user\r\n     * @param user the address of the user\r\n     * @return the unclaimed user rewards\r\n     */\r\n    function getUserUnclaimedRewards(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRewardsBalance(address[] calldata assets, address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILendingPool {\r\n   \r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n    /**\r\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n     *        borrowed at a stable rate and depositors are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n     * @param asset The address of the underlying asset deposited\r\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n     * For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts amounts being flash-borrowed\r\n     * @param modes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralETH the total collateral in ETH of the user\r\n     * @return totalDebtETH the total debt in ETH of the user\r\n     * @return availableBorrowsETH the borrowing power left of the user\r\n     * @return currentLiquidationThreshold the liquidation threshold of the user\r\n     * @return ltv the loan to value of the user\r\n     * @return healthFactor the current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n"
    },
    "contracts/strategies/aave/IStkAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface IStkAave {\r\n    function REWARD_TOKEN() external view returns (address);\r\n\r\n    function stake(address to, uint256 amount) external;\r\n\r\n    function redeem(address to, uint256 amount) external;\r\n\r\n    function cooldown() external;\r\n\r\n    function claimRewards(address to, uint256 amount) external;\r\n\r\n    function stakerRewardsToClaim(address _user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function stakersCooldowns(address _user) external view returns (uint256);\r\n    \r\n    //   mapping(address => uint256) public stakersCooldowns;\r\n}\r\n"
    },
    "contracts/strategies/compound/CompoundStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../../../yieldbox/contracts/strategies/BaseStrategy.sol';\r\nimport '../../swappers/NonYieldBoxMultiSwapper.sol';\r\n\r\nimport './ICToken.sol';\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n*/\r\n\r\ncontract CompoundStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    IERC20 public immutable wrappedNative;\r\n    NonYieldBoxMultiSwapper public swapper;\r\n\r\n    ICToken public immutable cToken;\r\n\r\n    /// @notice Queues tokens up to depositThreshold\r\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to Yearn is performed\r\n    uint256 public depositThreshold;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event DepositThreshold(uint256 _old, uint256 _new);\r\n    event AmountQueued(uint256 amount);\r\n    event AmountDeposited(uint256 amount);\r\n    event AmountWithdrawn(address indexed to, uint256 amount);\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _token,\r\n        address _cToken\r\n    ) BaseERC20Strategy(_yieldBox, _token) {\r\n        wrappedNative = IERC20(_token);\r\n        cToken = ICToken(_cToken);\r\n\r\n        wrappedNative.approve(_cToken, type(uint256).max);\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    /// @notice Returns the name of this strategy\r\n    function name() external pure override returns (string memory name_) {\r\n        return 'Compound';\r\n    }\r\n\r\n    /// @notice Returns the description of this strategy\r\n    function description()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory description_)\r\n    {\r\n        return 'Compound strategy for wrapped native assets';\r\n    }\r\n\r\n    function compoundAmount() public pure returns (uint256 result) {\r\n        return 0;\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n    /// @notice Sets the deposit threshold\r\n    /// @param amount The new threshold amount\r\n    function setDepositThreshold(uint256 amount) external onlyOwner {\r\n        emit DepositThreshold(depositThreshold, amount);\r\n        depositThreshold = amount;\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function compound(bool) public {}\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    function _currentBalance() internal view override returns (uint256 amount) {\r\n        uint256 shares = cToken.balanceOf(address(this));\r\n        uint256 pricePerShare = cToken.exchangeRateStored();\r\n        uint256 invested = (shares * pricePerShare) / (10**cToken.decimals());\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        return queued + invested;\r\n    }\r\n\r\n    /// @dev deposits to Compound or queues tokens if the 'depositThreshold' has not been met yet\r\n    ///      - when depositing to Compound, cToken is minted to this contract\r\n    function _deposited(uint256 amount) internal override nonReentrant {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > depositThreshold) {\r\n            cToken.mint(queued);\r\n            emit AmountDeposited(queued);\r\n            return;\r\n        }\r\n        emit AmountQueued(amount);\r\n    }\r\n\r\n    /// @dev burns yToken in exchange of Token and withdraws from Yearn Vault\r\n    function _withdraw(address to, uint256 amount)\r\n        internal\r\n        override\r\n        nonReentrant\r\n    {\r\n        uint256 available = _currentBalance();\r\n        require(available >= amount, 'CompoundStrategy: amount not valid');\r\n\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (amount > queued) {\r\n            uint256 pricePerShare = cToken.exchangeRateStored();\r\n            uint256 toWithdraw = (((amount - queued) *\r\n                (10**cToken.decimals())) / pricePerShare);\r\n\r\n            cToken.redeem(toWithdraw);\r\n        }\r\n        wrappedNative.safeTransfer(to, amount);\r\n\r\n        emit AmountWithdrawn(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICToken {\r\n    function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n    function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    function exchangeRateCurrent() external returns (uint256);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function underlying() external view returns (address);\r\n}\r\n"
    },
    "contracts/strategies/curve/ICurveMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICurveMinter {\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    function mint(address _gauge_addr) external;\r\n}\r\n"
    },
    "contracts/strategies/curve/ITricryptoLiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// solhint-disable var-name-mixedcase\r\n// solhint-disable func-name-mixedcase\r\n\r\ninterface ITricryptoLiquidityPool {\r\n    function coins(uint256 i) external view returns (address);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount)\r\n        external;\r\n\r\n    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts)\r\n        external;\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 _token_amount,\r\n        uint256 i,\r\n        uint256 min_amount\r\n    ) external;\r\n\r\n    function calc_withdraw_one_coin(uint256 token_amount, uint256 i)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calc_token_amount(uint256[3] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/curve/ITricryptoLPGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// solhint-disable var-name-mixedcase\r\n// solhint-disable func-name-mixedcase\r\n\r\ninterface ITricryptoLPGauge {\r\n    function crv_token() external view returns (address);\r\n\r\n    function deposit(\r\n        uint256 _value,\r\n        address _addr,\r\n        bool _claim_rewards\r\n    ) external;\r\n\r\n    function withdraw(uint256 value, bool _claim_rewards) external;\r\n\r\n    function claim_rewards(address _addr, address _receiver) external;\r\n\r\n    function claimable_tokens(address _addr) external returns (uint256);\r\n\r\n    function balanceOf(address _addr) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/curve/ITricryptoLPGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport './ITricryptoLiquidityPool.sol';\r\n\r\ninterface ITricryptoLPGetter {\r\n    /// @notice returns curve's liquidity pool\r\n    function liquidityPool() external returns (ITricryptoLiquidityPool);\r\n\r\n    /// @notice returns lp token address\r\n    function lpToken() external view returns (address);\r\n\r\n    /// @notice returns usdt address\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function USDT() external view returns (address);\r\n\r\n    /// @notice returns usdc address\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function WBTC() external view returns (address);\r\n\r\n    /// @notice returns dai address\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function WETH() external view returns (address);\r\n\r\n    /// @notice returns WETH amount for LP tokens\r\n    /// @param _lpAmount LP token amount\r\n    function calcLpToWeth(uint256 _lpAmount) external view returns (uint256);\r\n\r\n    /// @notice returns LP amount for WETH\r\n    /// @param _amount token amount\r\n    function calcWethToLp(uint256 _amount) external view returns (uint256);\r\n\r\n    /// @notice returns WBTC amount for LP tokens\r\n    /// @param _lpAmount LP token amount\r\n    function calcLpToWbtc(uint256 _lpAmount) external view returns (uint256);\r\n\r\n    /// @notice returns LP amount for WBTC\r\n    /// @param _amount token amount\r\n    function calcWbtcToLp(uint256 _amount) external view returns (uint256);\r\n\r\n    /// @notice returns USDT amount for LP tokens\r\n    /// @param _lpAmount LP token amount\r\n    function calcLpToUsdt(uint256 _lpAmount) external view returns (uint256);\r\n\r\n    /// @notice returns LP amount for USDT\r\n    /// @param _amount token amount\r\n    function calcUsdtToLp(uint256 _amount) external view returns (uint256);\r\n\r\n    /// @notice used to add USDT liquidity\r\n    /// @param _amount the amount of token to be used in the add liquidity operation\r\n    /// @param _minAmount the min amount of LP token to be received\r\n    function addLiquidityUsdt(uint256 _amount, uint256 _minAmount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /// @notice used to add WBTC liquidity\r\n    /// @param _amount the amount of token to be used in the add liquidity operation\r\n    /// @param _minAmount the min amount of LP token to be received\r\n    function addLiquidityWbtc(uint256 _amount, uint256 _minAmount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /// @notice used to add WETH liquidity\r\n    /// @param _amount the amount of token to be used in the add liquidity operation\r\n    /// @param _minAmount the min amount of LP token to be received\r\n    function addLiquidityWeth(uint256 _amount, uint256 _minAmount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /// @notice used to remove liquidity and get USDT\r\n    /// @param _amount the amount of LP token to be used in the remove liquidity operation\r\n    /// @param _minAmount the min amount of token to be received\r\n    function removeLiquidityUsdt(uint256 _amount, uint256 _minAmount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /// @notice used to remove liquidity and get WBTC\r\n    /// @param _amount the amount of LP token to be used in the remove liquidity operation\r\n    /// @param _minAmount the min amount of token to be received\r\n    function removeLiquidityWbtc(uint256 _amount, uint256 _minAmount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /// @notice used to remove liquidity and get WETH\r\n    /// @param _amount the amount of LP token to be used in the remove liquidity operation\r\n    /// @param _minAmount the min amount of token to be received\r\n    function removeLiquidityWeth(uint256 _amount, uint256 _minAmount)\r\n        external\r\n        returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/curve/TricryptoStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../../../yieldbox/contracts/strategies/BaseStrategy.sol';\r\nimport '../../swappers/NonYieldBoxMultiSwapper.sol';\r\n\r\nimport './ITricryptoLPGetter.sol';\r\nimport './ITricryptoLPGauge.sol';\r\nimport './ICurveMinter.sol';\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n*/\r\n\r\ncontract TricryptoStrategy is\r\n    BaseERC20Strategy,\r\n    BoringOwnable,\r\n    ReentrancyGuard\r\n{\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    IERC20 public immutable wrappedNative;\r\n    NonYieldBoxMultiSwapper public swapper;\r\n\r\n    ITricryptoLPGauge public immutable lpGauge;\r\n    ICurveMinter public immutable minter;\r\n    ITricryptoLPGetter public lpGetter;\r\n    IERC20 public immutable rewardToken; //CRV token\r\n\r\n    /// @notice Queues tokens up to depositThreshold\r\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\r\n    uint256 public depositThreshold;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event MultiSwapper(address indexed _old, address indexed _new);\r\n    event DepositThreshold(uint256 _old, uint256 _new);\r\n    event LPGetterSet(address indexed _old, address indexed _new);\r\n    event AmountQueued(uint256 amount);\r\n    event AmountDeposited(uint256 amount);\r\n    event AmountWithdrawn(address indexed to, uint256 amount);\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _token,\r\n        address _lpGauge,\r\n        address _lpGetter,\r\n        address _minter,\r\n        address _multiSwapper\r\n    ) BaseERC20Strategy(_yieldBox, _token) {\r\n        wrappedNative = IERC20(_token);\r\n        swapper = NonYieldBoxMultiSwapper(_multiSwapper);\r\n\r\n        lpGauge = ITricryptoLPGauge(_lpGauge);\r\n        minter = ICurveMinter(_minter);\r\n        lpGetter = ITricryptoLPGetter(_lpGetter);\r\n        rewardToken = IERC20(lpGauge.crv_token());\r\n\r\n        IERC20(lpGetter.lpToken()).approve(_lpGauge, type(uint256).max);\r\n        IERC20(lpGetter.lpToken()).approve(_lpGetter, type(uint256).max);\r\n        rewardToken.approve(_multiSwapper, type(uint256).max);\r\n        wrappedNative.approve(_lpGetter, type(uint256).max);\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    /// @notice Returns the name of this strategy\r\n    function name() external pure override returns (string memory name_) {\r\n        return 'Curve-Tricrypto';\r\n    }\r\n\r\n    /// @notice Returns the description of this strategy\r\n    function description()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory description_)\r\n    {\r\n        return 'Curve-Tricrypto strategy for wrapped native assets';\r\n    }\r\n\r\n    /// @notice returns compounded amounts in wrappedNative\r\n    function compoundAmount() public returns (uint256 result) {\r\n        uint256 claimable = lpGauge.claimable_tokens(address(this));\r\n        result = 0;\r\n        if (claimable > 0) {\r\n            address[] memory path = new address[](2); //todo: check if path is right\r\n            path[0] = address(rewardToken);\r\n            path[1] = address(wrappedNative);\r\n            result = swapper.getOutputAmount(path, claimable);\r\n        }\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n    /// @notice Sets the deposit threshold\r\n    /// @param amount The new threshold amount\r\n    function setDepositThreshold(uint256 amount) external onlyOwner {\r\n        emit DepositThreshold(depositThreshold, amount);\r\n        depositThreshold = amount;\r\n    }\r\n\r\n    /// @notice Sets the Swapper address\r\n    /// @param _swapper The new swapper address\r\n    function setMultiSwapper(address _swapper) external onlyOwner {\r\n        emit MultiSwapper(address(swapper), _swapper);\r\n        rewardToken.approve(address(swapper), 0);\r\n        rewardToken.approve(_swapper, type(uint256).max);\r\n        swapper = NonYieldBoxMultiSwapper(_swapper);\r\n    }\r\n\r\n    /// @notice Sets the Tricrypto LP Getter\r\n    /// @param _lpGetter the new address\r\n    function setTricryptoLPGetter(address _lpGetter) external onlyOwner {\r\n        emit LPGetterSet(address(lpGetter), _lpGetter);\r\n        wrappedNative.approve(address(lpGetter), 0);\r\n        lpGetter = ITricryptoLPGetter(_lpGetter);\r\n        wrappedNative.approve(_lpGetter, type(uint256).max);\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function compound(bool _tryStake) public {\r\n        uint256 claimable = lpGauge.claimable_tokens(address(this));\r\n        if (claimable > 0) {\r\n            uint256 crvBalanceBefore = rewardToken.balanceOf(address(this));\r\n            minter.mint(address(lpGauge));\r\n            uint256 crvBalanceAfter = rewardToken.balanceOf(address(this));\r\n\r\n            if (crvBalanceAfter > crvBalanceBefore) {\r\n                uint256 crvAmount = crvBalanceAfter - crvBalanceBefore;\r\n\r\n                address[] memory path = new address[](2); //todo: check if path is right\r\n                path[0] = address(rewardToken);\r\n                path[1] = address(wrappedNative);\r\n                uint256 calcAmount = swapper.getOutputAmount(path, crvAmount);\r\n                uint256 minAmount = (calcAmount * 2_500) / 10_000; //2.5%\r\n                swapper.swap(\r\n                    address(rewardToken),\r\n                    address(wrappedNative),\r\n                    minAmount,\r\n                    address(this),\r\n                    path,\r\n                    crvAmount\r\n                );\r\n\r\n                uint256 queued = wrappedNative.balanceOf(address(this));\r\n                if (_tryStake && queued > depositThreshold) {\r\n                    _addLiquidityAndStake(queued);\r\n                    emit AmountDeposited(queued);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    /// @dev queries Curve-Tricrypto Liquidity Pool\r\n    function _currentBalance() internal view override returns (uint256 amount) {\r\n        uint256 lpBalance = lpGauge.balanceOf(address(this));\r\n        uint256 assetAmount = lpGetter.calcLpToWeth(lpBalance);\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        return assetAmount + queued;\r\n    }\r\n\r\n    /// @dev deposits to Curve Tricrypto or queues tokens if the 'depositThreshold' has not been met yet\r\n    function _deposited(uint256 amount) internal override nonReentrant {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > depositThreshold) {\r\n            _addLiquidityAndStake(queued);\r\n            emit AmountDeposited(queued);\r\n            return;\r\n        }\r\n        emit AmountQueued(amount);\r\n    }\r\n\r\n    /// @dev withdraws from Curve Tricrypto\r\n    function _withdraw(address to, uint256 amount)\r\n        internal\r\n        override\r\n        nonReentrant\r\n    {\r\n        uint256 available = _currentBalance();\r\n        require(available >= amount, 'TricryptoStrategy: amount not valid');\r\n\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (amount > queued) {\r\n            compound(false);\r\n            uint256 lpBalance = lpGauge.balanceOf(address(this));\r\n            lpGauge.withdraw(lpBalance, true);\r\n            uint256 calcWithdraw = lpGetter.calcLpToWeth(lpBalance);\r\n            uint256 minAmount = (calcWithdraw * 2_500) / 10_000; //2.5%\r\n            uint256 assetAmount = lpGetter.removeLiquidityWeth(\r\n                lpBalance,\r\n                minAmount\r\n            );\r\n            require(\r\n                assetAmount + queued >= amount,\r\n                'TricryptoStrategy: not enough'\r\n            );\r\n        }\r\n\r\n        wrappedNative.safeTransfer(to, amount);\r\n\r\n        queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > 0) {\r\n            _addLiquidityAndStake(queued);\r\n        }\r\n        emit AmountWithdrawn(to, amount);\r\n    }\r\n\r\n    function _addLiquidityAndStake(uint256 amount) private {\r\n        uint256 calcAmount = lpGetter.calcWethToLp(amount);\r\n        uint256 minAmount = (calcAmount * 2_500) / 10_000; //2.5%\r\n        uint256 lpAmount = lpGetter.addLiquidityWeth(amount, minAmount);\r\n        lpGauge.deposit(lpAmount, address(this), false);\r\n    }\r\n}\r\n"
    },
    "contracts/strategies/interfaces/IAssetRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport '../../../yieldbox/contracts/interfaces/IStrategy.sol';\r\nimport '../../../yieldbox/contracts/enums/YieldBoxTokenType.sol';\r\n\r\ninterface IAssetRegister {\r\n    function ids(\r\n        TokenType tokenType,\r\n        address token,\r\n        IStrategy strategy,\r\n        uint256 id\r\n    ) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/interfaces/INative.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface INative {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 _wad) external;\r\n\r\n    function balanceOf(address _account) external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n}\r\n"
    },
    "contracts/strategies/lido/ICurveEthStEthPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface ICurveEthStEthPool {\r\n    // 0\ti\tint128\t1\r\n    // 1\tj\tint128\t0\r\n    // 2\tdx\tuint256\t9999999999999999\r\n    // 3\tmin_dy\tuint256\t9888206826924655\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external returns (uint256);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/lido/IStEth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface IStEth {\r\n    /**\r\n     * @notice Send funds to the pool with optional _referral parameter\r\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\r\n     * @return Amount of StETH shares generated\r\n     */\r\n    function submit(address _referral) external payable returns (uint256);\r\n\r\n    function balanceOf(address _user) external view returns (uint256);\r\n\r\n    function isStakingPaused() external view returns (bool);\r\n}\r\n"
    },
    "contracts/strategies/lido/LidoEthStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../../../yieldbox/contracts/strategies/BaseStrategy.sol';\r\n\r\nimport './IStEth.sol';\r\nimport './ICurveEthStEthPool.sol';\r\nimport '../interfaces/INative.sol';\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n*/\r\n\r\ncontract LidoEthStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    IERC20 public immutable wrappedNative;\r\n    IStEth public immutable stEth;\r\n    ICurveEthStEthPool public curveStEthPool;\r\n\r\n    /// @notice Queues tokens up to depositThreshold\r\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to AAVE is performed\r\n    uint256 public depositThreshold;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event DepositThreshold(uint256 _old, uint256 _new);\r\n    event AmountQueued(uint256 amount);\r\n    event AmountDeposited(uint256 amount);\r\n    event AmountWithdrawn(address indexed to, uint256 amount);\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _token,\r\n        address _stEth,\r\n        address _curvePool\r\n    ) BaseERC20Strategy(_yieldBox, _token) {\r\n        wrappedNative = IERC20(_token);\r\n        stEth = IStEth(_stEth);\r\n        curveStEthPool = ICurveEthStEthPool(_curvePool);\r\n\r\n        IERC20(_stEth).approve(_curvePool, type(uint256).max);\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    /// @notice Returns the name of this strategy\r\n    function name() external pure override returns (string memory name_) {\r\n        return 'Lido-ETH';\r\n    }\r\n\r\n    /// @notice Returns the description of this strategy\r\n    function description()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory description_)\r\n    {\r\n        return 'Lido-ETH strategy for wrapped native assets';\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n    /// @notice Sets the deposit threshold\r\n    /// @param amount The new threshold amount\r\n    function setDepositThreshold(uint256 amount) external onlyOwner {\r\n        emit DepositThreshold(depositThreshold, amount);\r\n        depositThreshold = amount;\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function compound(bool) public {}\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    /// @dev queries Lido and Curve Eth/STEth pools\r\n    function _currentBalance() internal view override returns (uint256 amount) {\r\n        uint256 stEthBalance = stEth.balanceOf(address(this));\r\n        uint256 calcEth = curveStEthPool.get_dy(1, 0, stEthBalance);\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        return calcEth + queued;\r\n    }\r\n\r\n    /// @dev deposits to Lido or queues tokens if the 'depositThreshold' has not been met yet\r\n    function _deposited(uint256 amount) internal override nonReentrant {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > depositThreshold) {\r\n            require(!stEth.isStakingPaused(), 'LidoStrategy: staking paused');\r\n            INative(address(wrappedNative)).withdraw(queued);\r\n            stEth.submit{value: queued}(address(0)); //1:1 between eth<>stEth\r\n            emit AmountDeposited(queued);\r\n            return;\r\n        }\r\n        emit AmountQueued(amount);\r\n    }\r\n\r\n    /// @dev swaps StEth with Eth\r\n    function _withdraw(address to, uint256 amount)\r\n        internal\r\n        override\r\n        nonReentrant\r\n    {\r\n        uint256 available = _currentBalance();\r\n        require(available >= amount, 'LidoStrategy: amount not valid');\r\n\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (amount > queued) {\r\n            uint256 toWithdraw = amount - queued; //1:1 between eth<>stEth\r\n            uint256 minAmount = (toWithdraw * 2_500) / 10_000; //2.5%\r\n            uint256 obtainedEth = curveStEthPool.exchange(\r\n                1,\r\n                0,\r\n                toWithdraw,\r\n                minAmount\r\n            );\r\n\r\n            INative(address(wrappedNative)).deposit{value: obtainedEth}();\r\n        }\r\n        queued = wrappedNative.balanceOf(address(this));\r\n        require(queued >= amount, 'LidoStrategy: not enough');\r\n\r\n        wrappedNative.safeTransfer(to, amount);\r\n\r\n        emit AmountWithdrawn(to, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/strategies/stargate/ILPStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILPStaking {\r\n    function deposit(uint256 _pid, uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _pid, uint256 _amount) external;\r\n\r\n    function emergencyWithdraw(uint256 _pid) external;\r\n\r\n    function pendingStargate(uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function poolLength() external view returns (uint256);\r\n\r\n    function updatePool(uint256 _pid) external;\r\n\r\n    function poolInfo(uint256 _index)\r\n        external\r\n        view\r\n        returns (\r\n            address lpToken,\r\n            uint256 allocPoint,\r\n            uint256 lastRewardBlock,\r\n            uint256 accStargatePerShare\r\n        );\r\n\r\n    function userInfo(address _user)\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 rewardDebt);\r\n\r\n    function stargate() external view returns (address);\r\n}\r\n"
    },
    "contracts/strategies/stargate/IRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouter {\r\n    struct lzTxObj {\r\n        uint256 dstGasForCall;\r\n        uint256 dstNativeAmount;\r\n        bytes dstNativeAddr;\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 _poolId,\r\n        uint256 _amountLD,\r\n        address _to\r\n    ) external;\r\n\r\n    function swap(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLD,\r\n        uint256 _minAmountLD,\r\n        lzTxObj memory _lzTxParams,\r\n        bytes calldata _to,\r\n        bytes calldata _payload\r\n    ) external payable;\r\n\r\n    function redeemRemote(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLP,\r\n        uint256 _minAmountLD,\r\n        bytes calldata _to,\r\n        lzTxObj memory _lzTxParams\r\n    ) external payable;\r\n\r\n    function instantRedeemLocal(\r\n        uint16 _srcPoolId,\r\n        uint256 _amountLP,\r\n        address _to\r\n    ) external returns (uint256);\r\n\r\n    function redeemLocal(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress,\r\n        uint256 _amountLP,\r\n        bytes calldata _to,\r\n        lzTxObj memory _lzTxParams\r\n    ) external payable;\r\n\r\n    function sendCredits(\r\n        uint16 _dstChainId,\r\n        uint256 _srcPoolId,\r\n        uint256 _dstPoolId,\r\n        address payable _refundAddress\r\n    ) external payable;\r\n\r\n    function quoteLayerZeroFee(\r\n        uint16 _dstChainId,\r\n        uint8 _functionType,\r\n        bytes calldata _toAddress,\r\n        bytes calldata _transferAndCallPayload,\r\n        lzTxObj memory _lzTxParams\r\n    ) external view returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/strategies/stargate/IRouterETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouterETH {\r\n    function addLiquidityETH() external payable;\r\n\r\n    function stargateEthVault() external view returns (address); //STGETH\r\n\r\n    function poolId() external view returns (uint16);\r\n\r\n    function stargateRouter() external view returns (address);\r\n\r\n}\r\n"
    },
    "contracts/strategies/stargate/StargateStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../../../yieldbox/contracts/strategies/BaseStrategy.sol';\r\nimport '../../swappers/NonYieldBoxMultiSwapper.sol';\r\n\r\nimport './IRouter.sol';\r\nimport './IRouterETH.sol';\r\nimport './ILPStaking.sol';\r\nimport '../interfaces/INative.sol';\r\n\r\nimport 'hardhat/console.sol';\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n*/\r\n\r\n//TODO: decide if we need to start with ETH and wrap it into WETH; stargate allows ETH. not WETH, while others allow WETH, not ETH\r\n//TODO: handle rewards deposits to yieldbox\r\n\r\n//Wrapped-native strategy for Stargate\r\ncontract StargateStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    IERC20 public immutable wrappedNative;\r\n    NonYieldBoxMultiSwapper public swapper;\r\n\r\n    IRouterETH public immutable addLiquidityRouter;\r\n    IRouter public immutable router;\r\n    ILPStaking public immutable lpStaking;\r\n\r\n    uint256 public lpStakingPid;\r\n    uint256 public lpRouterPid;\r\n    IERC20 public stgNative; //ex: stEth\r\n    IERC20 public stgTokenReward;\r\n\r\n    /// @notice Queues tokens up to depositThreshold\r\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to Stargate is performed\r\n    uint256 public depositThreshold;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event MultiSwapper(address indexed _old, address indexed _new);\r\n    event DepositThreshold(uint256 _old, uint256 _new);\r\n    event AmountQueued(uint256 amount);\r\n    event AmountDeposited(uint256 amount);\r\n    event AmountWithdrawn(address indexed to, uint256 amount);\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _token,\r\n        address _ethRouter,\r\n        address _lpStaking,\r\n        uint256 _stakingPid,\r\n        address _lpToken,\r\n        address _multiSwapper\r\n    ) BaseERC20Strategy(_yieldBox, _token) {\r\n        wrappedNative = IERC20(_token);\r\n        swapper = NonYieldBoxMultiSwapper(_multiSwapper);\r\n\r\n        addLiquidityRouter = IRouterETH(_ethRouter);\r\n        lpStaking = ILPStaking(_lpStaking);\r\n        lpStakingPid = _stakingPid;\r\n\r\n        router = IRouter(addLiquidityRouter.stargateRouter());\r\n        lpRouterPid = addLiquidityRouter.poolId();\r\n\r\n        stgNative = IERC20(_lpToken);\r\n        stgNative.approve(_lpStaking, type(uint256).max);\r\n        stgNative.approve(address(router), type(uint256).max);\r\n\r\n        stgTokenReward = IERC20(lpStaking.stargate());\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    /// @notice Returns the name of this strategy\r\n    function name() external pure override returns (string memory name_) {\r\n        return 'Stargate';\r\n    }\r\n\r\n    /// @notice Returns the description of this strategy\r\n    function description()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory description_)\r\n    {\r\n        return 'Stargate strategy for wrapped native assets';\r\n    }\r\n\r\n    /// @notice returns compounded amounts in wrappedNative\r\n    function compoundAmount() public view returns (uint256 result) {\r\n        uint256 claimable = lpStaking.pendingStargate(\r\n            lpStakingPid,\r\n            address(this)\r\n        );\r\n        result = 0;\r\n        if (claimable > 0) {\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(stgTokenReward);\r\n            path[1] = address(wrappedNative);\r\n            result = swapper.getOutputAmount(path, claimable);\r\n        }\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n    /// @notice Sets the deposit threshold\r\n    /// @param amount The new threshold amount\r\n    function setDepositThreshold(uint256 amount) external onlyOwner {\r\n        emit DepositThreshold(depositThreshold, amount);\r\n        depositThreshold = amount;\r\n    }\r\n\r\n    /// @notice Sets the Swapper address\r\n    /// @param _swapper The new swapper address\r\n    function setMultiSwapper(address _swapper) external onlyOwner {\r\n        emit MultiSwapper(address(swapper), _swapper);\r\n        swapper = NonYieldBoxMultiSwapper(_swapper);\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function compound(bool _tryStake) public {\r\n        uint256 unclaimed = lpStaking.pendingStargate(\r\n            lpStakingPid,\r\n            address(this)\r\n        );\r\n\r\n        if (unclaimed > 0) {\r\n            uint256 stgBalanceBefore = stgTokenReward.balanceOf(address(this));\r\n            lpStaking.deposit(2, 0);\r\n            uint256 stgBalanceAfter = stgTokenReward.balanceOf(address(this));\r\n\r\n            if (stgBalanceAfter > stgBalanceBefore) {\r\n                uint256 stgAmount = stgBalanceAfter - stgBalanceBefore;\r\n\r\n                address[] memory path = new address[](2); //todo: check if path is right\r\n                path[0] = address(stgTokenReward);\r\n                path[1] = address(wrappedNative);\r\n                uint256 calcAmount = swapper.getOutputAmount(path, stgAmount);\r\n                uint256 minAmount = (calcAmount * 2_500) / 10_000; //2.5%\r\n                swapper.swap(\r\n                    address(stgTokenReward),\r\n                    address(wrappedNative),\r\n                    minAmount,\r\n                    address(this),\r\n                    path,\r\n                    stgAmount\r\n                );\r\n\r\n                //stake if > depositThreshold\r\n                uint256 queued = wrappedNative.balanceOf(address(this));\r\n                if (_tryStake && queued > depositThreshold) {\r\n                    _stake(queued);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    /// @dev queries 'getUserAccountData' from Stargate and gets the total collateral\r\n    function _currentBalance() internal view override returns (uint256 amount) {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        (amount, ) = lpStaking.userInfo(address(this));\r\n        uint256 claimableRewards = compoundAmount();\r\n        return amount + queued + claimableRewards;\r\n    }\r\n\r\n    /// @dev deposits to Stargate or queues tokens if the 'depositThreshold' has not been met yet\r\n    ///      - when depositing to Stargate, aToken is minted to this contract\r\n    function _deposited(uint256 amount) internal override nonReentrant {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > depositThreshold) {\r\n            _stake(queued);\r\n        }\r\n        emit AmountQueued(amount);\r\n    }\r\n\r\n    function _stake(uint256 amount) private {\r\n        INative(address(wrappedNative)).withdraw(amount);\r\n\r\n        addLiquidityRouter.addLiquidityETH{value: amount}();\r\n        uint256 toStake = stgNative.balanceOf(address(this));\r\n        lpStaking.deposit(lpStakingPid, toStake);\r\n        emit AmountDeposited(amount);\r\n    }\r\n\r\n    /// @dev burns stgToken in exchange of Native and withdraws from Stargate Staking & Router\r\n    function _withdraw(address to, uint256 amount)\r\n        internal\r\n        override\r\n        nonReentrant\r\n    {\r\n        uint256 available = _currentBalance();\r\n        require(available >= amount, 'StargateStrategy: amount not valid');\r\n\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (amount > queued) {\r\n            compound(false);\r\n            uint256 toWithdraw = amount - queued;\r\n            lpStaking.withdraw(lpStakingPid, toWithdraw);\r\n            router.instantRedeemLocal(\r\n                uint16(lpRouterPid),\r\n                toWithdraw,\r\n                address(this)\r\n            );\r\n            INative(address(wrappedNative)).deposit{value: amount}();\r\n        }\r\n\r\n        wrappedNative.safeTransfer(to, amount);\r\n\r\n        emit AmountWithdrawn(to, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/strategies/yearn/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function deposit(uint256 _amount, address _recipient)\r\n        external\r\n        returns (uint256);\r\n\r\n    function withdraw(\r\n        uint256 _maxShares,\r\n        address _recipient,\r\n        uint256 _maxLoss\r\n    ) external returns (uint256);\r\n\r\n    function balanceOf(address _recipient) external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function governance() external view returns (address);\r\n\r\n    function management() external view returns (address);\r\n\r\n    function guardian() external view returns (address);\r\n\r\n    function emergencyShutdown() external view returns (bool);\r\n\r\n    function depositLimit() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/strategies/yearn/YearnStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../../../yieldbox/contracts/strategies/BaseStrategy.sol';\r\n\r\nimport './IYearnVault.sol';\r\n\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n*/\r\n\r\n//TODO: decide if we need to start with ETH and wrap it into WETH; stargate allows ETH. not WETH, while others allow WETH, not ETH\r\n//TODO: handle rewards deposits to yieldbox\r\n\r\n//Wrapped-native strategy for Yearn\r\ncontract YearnStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    IERC20 public immutable wrappedNative;\r\n    IYearnVault public immutable vault;\r\n\r\n    /// @notice Queues tokens up to depositThreshold\r\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to Yearn is performed\r\n    uint256 public depositThreshold;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n    event DepositThreshold(uint256 _old, uint256 _new);\r\n    event AmountQueued(uint256 amount);\r\n    event AmountDeposited(uint256 amount);\r\n    event AmountWithdrawn(address indexed to, uint256 amount);\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _token,\r\n        address _vault\r\n    ) BaseERC20Strategy(_yieldBox, _token) {\r\n        wrappedNative = IERC20(_token);\r\n        vault = IYearnVault(_vault);\r\n\r\n        wrappedNative.approve(address(vault), type(uint256).max);\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    /// @notice Returns the name of this strategy\r\n    function name() external pure override returns (string memory name_) {\r\n        return 'Yearn';\r\n    }\r\n\r\n    /// @notice Returns the description of this strategy\r\n    function description()\r\n        external\r\n        pure\r\n        override\r\n        returns (string memory description_)\r\n    {\r\n        return 'Yearn strategy for wrapped native assets';\r\n    }\r\n\r\n    function compoundAmount() public pure returns (uint256 result) {\r\n        return 0;\r\n    }\r\n\r\n    // *********************** //\r\n    // *** OWNER FUNCTIONS *** //\r\n    // *********************** //\r\n    /// @notice Sets the deposit threshold\r\n    /// @param amount The new threshold amount\r\n    function setDepositThreshold(uint256 amount) external onlyOwner {\r\n        emit DepositThreshold(depositThreshold, amount);\r\n        depositThreshold = amount;\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function compound(bool) public {}\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    function _currentBalance() internal view override returns (uint256 amount) {\r\n        uint256 shares = vault.balanceOf(address(this));\r\n        uint256 pricePerShare = vault.pricePerShare();\r\n        uint256 invested = (shares * pricePerShare) / (10**vault.decimals());\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        return queued + invested;\r\n    }\r\n\r\n    /// @dev deposits to Yearn or queues tokens if the 'depositThreshold' has not been met yet\r\n    ///      - when depositing to Yearn, yToken is minted to this contract\r\n    function _deposited(uint256 amount) internal override nonReentrant {\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (queued > depositThreshold) {\r\n            vault.deposit(queued, address(this));\r\n            emit AmountDeposited(queued);\r\n            return;\r\n        }\r\n        emit AmountQueued(amount);\r\n    }\r\n\r\n    /// @dev burns yToken in exchange of Token and withdraws from Yearn Vault\r\n    function _withdraw(address to, uint256 amount)\r\n        internal\r\n        override\r\n        nonReentrant\r\n    {\r\n        uint256 available = _currentBalance();\r\n        require(available >= amount, 'YearnStrategy: amount not valid');\r\n\r\n        uint256 queued = wrappedNative.balanceOf(address(this));\r\n        if (amount > queued) {\r\n            uint256 pricePerShare = vault.pricePerShare();\r\n            uint256 toWithdraw = (((amount - queued) * (10**vault.decimals())) /\r\n                pricePerShare);\r\n\r\n            uint256 returned = vault.withdraw(toWithdraw, address(this), 0);\r\n        }\r\n        wrappedNative.safeTransfer(to, amount);\r\n\r\n        emit AmountWithdrawn(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/CurveSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport '../libraries/ICurvePool.sol';\nimport '../../yieldbox/contracts/YieldBox.sol';\nimport '../IBeachBar.sol';\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\n/// @title Curve pool swapper\ncontract CurveSwapper {\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    ICurvePool public curvePool;\n\n    YieldBox private immutable yieldBox;\n\n    /// @notice creates a new CurveSwapper contract\n    /// @param _curvePool CurvePool address\n    /// @param _bar BeachBar address\n    constructor(ICurvePool _curvePool, IBeachBar _bar) {\n        curvePool = _curvePool;\n        yieldBox = YieldBox(_bar.yieldBox());\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n\n    /// @notice returns the possible output amount for input share\n    /// @param tokenInId YieldBox asset id\n    /// @param tokenIndexes The input and the output Curve's pool indexes\n    /// @param shareIn Shares to get the amount for\n    function getOutputAmount(\n        uint256 tokenInId,\n        uint256[] calldata tokenIndexes,\n        uint256 shareIn\n    ) external view returns (uint256 amountOut) {\n        uint256 amountIn = yieldBox.toAmount(tokenInId, shareIn, false);\n        amountOut = curvePool.get_dy(\n            int128(int256(tokenIndexes[0])),\n            int128(int256(tokenIndexes[1])),\n            amountIn\n        );\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice swaps token in with token out\n    /// @dev returns both amount and shares\n    /// @param tokenInId YieldBox asset id\n    /// @param tokenOutId YieldBox asset id\n    /// @param tokenIndexes The input and the output Curve's pool indexes\n    /// @param shareIn Shares to be swapped\n    /// @param amountOutMin Minimum amount to be received\n    /// @param to Receiver address\n    function swap(\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256[] calldata tokenIndexes,\n        uint256 shareIn,\n        uint256 amountOutMin,\n        address to\n    ) external returns (uint256 amountOut, uint256 shareOut) {\n        (uint256 amountIn, ) = yieldBox.withdraw(\n            tokenInId,\n            address(this),\n            address(this),\n            0,\n            shareIn\n        );\n\n        amountOut = _swapTokensForTokens(\n            int128(int256(tokenIndexes[0])),\n            int128(int256(tokenIndexes[1])),\n            amountIn,\n            amountOutMin\n        );\n\n        (, address tokenOutAddress, , ) = yieldBox.assets(tokenOutId);\n        IERC20(tokenOutAddress).approve(address(yieldBox), amountOut);\n        (, shareOut) = yieldBox.depositAsset(\n            tokenOutId,\n            address(this),\n            to,\n            amountOut,\n            0\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _swapTokensForTokens(\n        int128 i,\n        int128 j,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) private returns (uint256) {\n        address tokenOut = curvePool.coins(uint256(uint128(j)));\n\n        uint256 outputAmount = curvePool.get_dy(i, j, amountIn);\n        require(outputAmount >= amountOutMin, 'insufficient-amount-out');\n\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n        curvePool.exchange(i, j, amountIn, amountOutMin);\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(address(this));\n        require(balanceAfter > balanceBefore, 'swap failed');\n\n        return balanceAfter - balanceBefore;\n    }\n}\n"
    },
    "contracts/swappers/ICurveSwapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ICurveSwapper {\n    function curvePool() external view returns (address);\n\n    function yieldBox() external view returns (address);\n\n    /// @notice returns the possible output amount for input share\n    /// @param tokenInId YieldBox asset id\n    /// @param tokenIndexes The input and the output Curve's pool indexes\n    /// @param shareIn Shares to get the amount for\n    function getOutputAmount(\n        uint256 tokenInId,\n        uint256[] calldata tokenIndexes,\n        uint256 shareIn\n    ) external view returns (uint256 amountOut);\n\n    /// @notice swaps token in with token out\n    /// @dev returns both amount and shares\n    /// @param tokenInId YieldBox asset id\n    /// @param tokenOutId YieldBox asset id\n    /// @param tokenIndexes The input and the output Curve's pool indexes\n    /// @param shareIn Shares to be swapped\n    /// @param amountOutMin Minimum amount to be received\n    /// @param to Receiver address\n    function swap(\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256[] calldata tokenIndexes,\n        uint256 shareIn,\n        uint256 amountOutMin,\n        address to\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n"
    },
    "contracts/swappers/IMultiSwapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IMultiSwapper {\n    function swap(\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256 amountMinOut,\n        address to,\n        address[] calldata path,\n        uint256 shareIn\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    function getOutputAmount(\n        uint256 tokenInId,\n        address[] calldata path,\n        uint256 shareIn\n    ) external view returns (uint256 amountOut);\n\n    function getInputAmount(\n        uint256 tokenOutId,\n        address[] calldata path,\n        uint256 shareOut\n    ) external view returns (uint256 amountIn);\n}\n"
    },
    "contracts/swappers/MultiSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\nimport '../IBeachBar.sol';\nimport '../libraries/IUniswapV2Factory.sol';\nimport '../libraries/UniswapV2Library.sol';\nimport '../libraries/IUniswapV2Pair.sol';\nimport '../../yieldbox/contracts//YieldBox.sol';\n\n/// Modified from https://github.com/sushiswap/kashi-lending/blob/master/contracts/swappers/SushiSwapMultiSwapper.sol\n\ncontract MultiSwapper {\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    address private immutable factory;\n    YieldBox private immutable yieldBox;\n    bytes32 private immutable pairCodeHash;\n\n    /// @notice creates a new MultiSwapper contract\n    /// @param _factory UniswapV2Factory address\n    /// @param _tapiocaBar BeachBar address\n    /// @param _pairCodeHash UniswapV2 pair code hash\n    constructor(\n        address _factory,\n        IBeachBar _tapiocaBar,\n        bytes32 _pairCodeHash\n    ) {\n        factory = _factory;\n        yieldBox = YieldBox(_tapiocaBar.yieldBox());\n        pairCodeHash = _pairCodeHash;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    function getOutputAmount(\n        uint256 tokenInId,\n        address[] calldata path,\n        uint256 shareIn\n    ) external view returns (uint256 amountOut) {\n        uint256 amountIn = yieldBox.toAmount(tokenInId, shareIn, false);\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(\n            factory,\n            amountIn,\n            path,\n            pairCodeHash\n        );\n        amountOut = amounts[amounts.length - 1];\n    }\n\n    function getInputAmount(\n        uint256 tokenOutId,\n        address[] calldata path,\n        uint256 shareOut\n    ) external view returns (uint256 amountIn) {\n        uint256 amountOut = yieldBox.toAmount(tokenOutId, shareOut, false);\n        uint256[] memory amounts = UniswapV2Library.getAmountsIn(\n            factory,\n            amountOut,\n            path,\n            pairCodeHash\n        );\n        amountIn = amounts[0];\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function swap(\n        uint256 tokenInId,\n        uint256 tokenOutId,\n        uint256 amountMinOut,\n        address to,\n        address[] calldata path,\n        uint256 shareIn\n    ) external returns (uint256 amountOut, uint256 shareOut) {\n        (uint256 amountIn, ) = yieldBox.withdraw(\n            tokenInId,\n            address(this),\n            address(this),\n            0,\n            shareIn\n        );\n\n        amountOut = _swapExactTokensForTokens(\n            amountIn,\n            amountMinOut,\n            path,\n            address(this)\n        );\n\n        IERC20(path[path.length - 1]).approve(address(yieldBox), amountOut);\n        (, shareOut) = yieldBox.depositAsset(\n            tokenOutId,\n            address(this),\n            to,\n            amountOut,\n            0\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    // Swaps an exact amount of tokens for another token through the path passed as an argument\n    // Returns the amount of the final token\n    function _swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to\n    ) internal returns (uint256 amountOut) {\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(\n            factory,\n            amountIn,\n            path,\n            pairCodeHash\n        );\n        amountOut = amounts[amounts.length - 1];\n        require(amountOut >= amountOutMin, 'insufficient-amount-out');\n        // Required for the next step\n        IERC20(path[0]).safeTransfer(\n            UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash),\n            amountIn\n        );\n        _swap(amounts, path, to);\n    }\n\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < path.length - 2\n                ? UniswapV2Library.pairFor(\n                    factory,\n                    output,\n                    path[i + 2],\n                    pairCodeHash\n                )\n                : _to;\n\n            IUniswapV2Pair(\n                UniswapV2Library.pairFor(factory, input, output, pairCodeHash)\n            ).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n}\n"
    },
    "contracts/swappers/NonYieldBoxMultiSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\r\n\r\nimport '../libraries/IUniswapV2Factory.sol';\r\nimport '../libraries/UniswapV2Library.sol';\r\nimport '../libraries/IUniswapV2Pair.sol';\r\n\r\n/// Modified from https://github.com/sushiswap/kashi-lending/blob/master/contracts/swappers/SushiSwapMultiSwapper.sol\r\n\r\ncontract NonYieldBoxMultiSwapper {\r\n    using BoringERC20 for IERC20;\r\n\r\n    // ************ //\r\n    // *** VARS *** //\r\n    // ************ //\r\n    address private immutable factory;\r\n    bytes32 private immutable pairCodeHash;\r\n\r\n    /// @notice creates a new MultiSwapper contract\r\n    /// @param _factory UniswapV2Factory address\r\n    /// @param _pairCodeHash UniswapV2 pair code hash\r\n    constructor(address _factory, bytes32 _pairCodeHash) {\r\n        factory = _factory;\r\n        pairCodeHash = _pairCodeHash;\r\n    }\r\n\r\n    // ********************** //\r\n    // *** VIEW FUNCTIONS *** //\r\n    // ********************** //\r\n    function getOutputAmount(address[] calldata path, uint256 amountIn)\r\n        external\r\n        view\r\n        returns (uint256 amountOut)\r\n    {\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(\r\n            factory,\r\n            amountIn,\r\n            path,\r\n            pairCodeHash\r\n        );\r\n        amountOut = amounts[amounts.length - 1];\r\n    }\r\n\r\n    function getInputAmount(address[] calldata path, uint256 amountOut)\r\n        external\r\n        view\r\n        returns (uint256 amountIn)\r\n    {\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsIn(\r\n            factory,\r\n            amountOut,\r\n            path,\r\n            pairCodeHash\r\n        );\r\n        amountIn = amounts[0];\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n    function swap(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountMinOut,\r\n        address to,\r\n        address[] calldata path,\r\n        uint256 amountIn\r\n    ) external returns (uint256 amountOut) {\r\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\r\n\r\n        amountOut = _swapExactTokensForTokens(\r\n            amountIn,\r\n            amountMinOut,\r\n            path,\r\n            address(this)\r\n        );\r\n\r\n        IERC20(tokenOut).safeTransfer(to, amountOut);\r\n    }\r\n\r\n    // ************************* //\r\n    // *** PRIVATE FUNCTIONS *** //\r\n    // ************************* //\r\n    // Swaps an exact amount of tokens for another token through the path passed as an argument\r\n    // Returns the amount of the final token\r\n    function _swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] memory path,\r\n        address to\r\n    ) internal returns (uint256 amountOut) {\r\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(\r\n            factory,\r\n            amountIn,\r\n            path,\r\n            pairCodeHash\r\n        );\r\n        amountOut = amounts[amounts.length - 1];\r\n        require(amountOut >= amountOutMin, 'insufficient-amount-out');\r\n        // Required for the next step\r\n        IERC20(path[0]).safeTransfer(\r\n            UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash),\r\n            amountIn\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\r\n                ? (uint256(0), amountOut)\r\n                : (amountOut, uint256(0));\r\n            address to = i < path.length - 2\r\n                ? UniswapV2Library.pairFor(\r\n                    factory,\r\n                    output,\r\n                    path[i + 2],\r\n                    pairCodeHash\r\n                )\r\n                : _to;\r\n\r\n            IUniswapV2Pair(\r\n                UniswapV2Library.pairFor(factory, input, output, pairCodeHash)\r\n            ).swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/usd0/IUSD0.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\n\ninterface IUSD0 is IStrictERC20 {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n"
    },
    "contracts/usd0/MinterSingularity.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport '@boringcrypto/boring-solidity/contracts/BoringOwnable.sol';\nimport '@boringcrypto/boring-solidity/contracts/ERC20.sol';\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol';\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol';\n\nimport '../IBeachBar.sol';\nimport '../swappers/IMultiSwapper.sol';\nimport '../singularity/interfaces/IOracle.sol';\nimport '../../yieldbox/contracts/YieldBox.sol';\n\n// solhint-disable max-line-length\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n\n*/\n\ncontract MinterSingularity is BoringOwnable, ERC20 {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    struct AccrueInfo {\n        uint64 stabilityFee;\n        uint64 lastAccrued;\n    }\n    AccrueInfo public accrueInfo;\n\n    IBeachBar public beachBar;\n    YieldBox public yieldBox;\n    IERC20 public collateral;\n    IUSD0 public asset;\n    uint256 public collateralId;\n    uint256 public assetId;\n\n    // Total amounts\n    uint256 public totalCollateralShare; // Total collateral supplied\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    uint256 public totalBorrowCap;\n\n    // User balances\n    mapping(address => uint256) public userCollateralShare;\n    // userAssetFraction is called balanceOf for ERC20 compatibility (it's in ERC20.sol)\n\n    mapping(address => uint256) public userBorrowPart;\n\n    // map of operator approval\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n    uint256 public borrowingFee;\n\n    IOracle oracle;\n    bytes public oracleData;\n    address[] tapSwapPath; // Asset -> Tap\n    address[] collateralSwapPath; // Collateral -> Asset\n\n    //errors\n    error NotApproved(address _from, address _operator);\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event LogExchangeRate(uint256 rate);\n    event LogAccrue(uint256 accruedAmount, uint64 rate);\n    event LogAddCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    event LogRemoveCollateral(\n        address indexed from,\n        address indexed to,\n        uint256 share\n    );\n    event LogBorrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 feeAmount,\n        uint256 part\n    );\n    event LogRepay(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 part\n    );\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarned);\n    event LogYieldBoxFeesDeposit(uint256 feeShares, uint256 tapAmount);\n    event LogApprovalForAll(\n        address indexed _from,\n        address indexed _operator,\n        bool _approved\n    );\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    event LogStabilityFee(uint256 _oldFee, uint256 _newFee);\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    event LogCollateralSwapPath();\n    event LogTapSwapPath();\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\n    uint256 internal constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\n    uint256 private constant BORROW_OPENING_FEE_PRECISION = 1e5;\n    uint256 private constant PROTOCOL_FEE_DIVISOR = 1e5;\n    uint256 internal constant CALLER_FEE_DIVISOR = 1e5;\n\n    uint256 internal constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\n    uint256 internal constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\n    uint256 internal constant CALLER_FEE = 90000; // 90%\n    uint256 private constant PROTOCOL_FEE = 10000; // 10%\n\n    uint256 private constant MAX_BORROWING_FEE = 8e4; //at 80% for testing; TBD\n    uint256 private constant MAX_STABILITY_FEE = 8e17; //at 80% for testing; TBD\n\n    // ***************** //\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.\n    /// If 'from' is msg.sender, it's allowed.\n    /// If 'msg.sender' is an address (an operator) that is approved by 'from', it's allowed.\n    modifier allowed(address from) virtual {\n        if (\n            from != msg.sender && allowance[from][msg.sender] <= balanceOf[from]\n        ) {\n            revert NotApproved(from, msg.sender);\n        }\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        _;\n        require(_isSolvent(from, exchangeRate), 'Mx: insolvent');\n    }\n\n    /// @notice Creates the MinterSingularity contract\n    constructor(\n        IBeachBar tapiocaBar_,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        IOracle _oracle,\n        address[] memory _tapSwapPath,\n        address[] memory _collateralSwapPath\n    ) {\n        beachBar = tapiocaBar_;\n        yieldBox = YieldBox(tapiocaBar_.yieldBox());\n        owner = address(beachBar);\n\n        tapSwapPath = _tapSwapPath;\n        collateralSwapPath = _collateralSwapPath;\n\n        address _asset = beachBar.usdoToken();\n\n        require(\n            address(_collateral) != address(0) &&\n                address(_asset) != address(0) &&\n                address(_oracle) != address(0),\n            'Mx: bad pair'\n        );\n\n        asset = IUSD0(_asset);\n        assetId = beachBar.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n\n        accrueInfo.stabilityFee = 317097920; // aprox 1% APR, with 1e18 being 100%\n\n        updateExchangeRate();\n\n        owner = msg.sender;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    function symbol() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    'tmsgl',\n                    collateral.safeSymbol(),\n                    '/',\n                    asset.symbol(),\n                    '-',\n                    oracle.symbol(oracleData)\n                )\n            );\n    }\n\n    function name() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    'Tapioca MinterSingularity ',\n                    collateral.safeName(),\n                    '/',\n                    asset.name(),\n                    '-',\n                    oracle.name(oracleData)\n                )\n            );\n    }\n\n    function decimals() external view returns (uint8) {\n        return asset.decimals();\n    }\n\n    // totalSupply for ERC20 compatibility\n    // BalanceOf[user] represent a fraction\n    function totalSupply() public view override returns (uint256) {\n        return asset.totalSupply();\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USD0 at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get('');\n\n        if (updated) {\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 extraAmount = 0;\n\n        // Calculate fees\n        extraAmount =\n            (uint256(_totalBorrow.elastic) *\n                _accrueInfo.stabilityFee *\n                elapsedTime) /\n            1e18;\n        _totalBorrow.elastic += uint128(extraAmount);\n\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount, _accrueInfo.stabilityFee);\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) public solvent(from) allowed(from) returns (uint256 part, uint256 share) {\n        accrue();\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address from,\n        address to,\n        uint256 part\n    ) public allowed(from) returns (uint256 amount) {\n        accrue();\n        amount = _repay(from, to, part);\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param from Account to transfer shares from.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address from,\n        address to,\n        bool skim,\n        uint256 share\n    ) public allowed(from) {\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param from Account to debit collateral from.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) public solvent(from) allowed(from) {\n        // accrue must be called because we check solvency\n        accrue();\n\n        _removeCollateral(from, to, share);\n    }\n\n    /// @notice Withdraw the balance of `feeTo`, swap asset into TAP and deposit it to yieldBox of `feeTo`\n    function depositFeesToYieldBox(\n        IMultiSwapper swapper,\n        IBeachBar.SwapData calldata swapData\n    ) public {\n        require(beachBar.swappers(swapper), 'Mx: Invalid swapper');\n\n        uint256 balance = asset.balanceOf(address(this));\n        balanceOf[beachBar.feeTo()] += balance;\n\n        emit LogWithdrawFees(beachBar.feeTo(), balance);\n\n        address _feeTo = beachBar.feeTo();\n        address _feeVeTap = beachBar.feeVeTap();\n\n        if (balanceOf[_feeTo] > 0) {\n            uint256 feeShares = yieldBox.toShare(\n                assetId,\n                balanceOf[_feeTo],\n                false\n            );\n\n            asset.approve(address(yieldBox), balanceOf[_feeTo]);\n            yieldBox.depositAsset(\n                assetId,\n                address(this),\n                address(this),\n                balanceOf[_feeTo],\n                0\n            );\n\n            balanceOf[_feeTo] = 0;\n            yieldBox.transfer(\n                address(this),\n                address(swapper),\n                assetId,\n                feeShares\n            );\n            (uint256 tapAmount, ) = swapper.swap(\n                assetId,\n                beachBar.tapAssetId(),\n                swapData.minAssetAmount,\n                _feeVeTap,\n                tapSwapPath,\n                feeShares\n            );\n\n            emit LogYieldBoxFeesDeposit(feeShares, tapAmount);\n        }\n    }\n\n    /// @notice Entry point for liquidations.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param collateralToAssetSwapData Extra swap data\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        IMultiSwapper swapper,\n        bytes calldata collateralToAssetSwapData\n    ) external {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        accrue();\n\n        _closedLiquidation(\n            users,\n            maxBorrowParts,\n            swapper,\n            _exchangeRate,\n            collateralToAssetSwapData\n        );\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n\n    /// @notice Used to set the swap path of closed liquidations\n    /// @param _collateralSwapPath The Uniswap path .\n    function setCollateralSwapPath(address[] calldata _collateralSwapPath)\n        public\n        onlyOwner\n    {\n        collateralSwapPath = _collateralSwapPath;\n        emit LogCollateralSwapPath();\n    }\n\n    /// @notice Used to set the swap path of Asset -> TAP\n    /// @param _tapSwapPath The Uniswap path .\n    function setTapSwapPath(address[] calldata _tapSwapPath) public onlyOwner {\n        tapSwapPath = _tapSwapPath;\n        emit LogTapSwapPath();\n    }\n\n    /// @notice sets max borrowable amount\n    function setBorrowCap(uint256 _cap) external onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice Updates the stability fee\n    /// @param _stabilityFee the new value\n    function updateStabilityFee(uint64 _stabilityFee) external onlyOwner {\n        require(_stabilityFee <= MAX_STABILITY_FEE, 'Mx: value not valid');\n        emit LogStabilityFee(accrueInfo.stabilityFee, _stabilityFee);\n        accrueInfo.stabilityFee = _stabilityFee;\n    }\n\n    /// @notice Updates the borrowing fee\n    /// @param _borrowingFee the new value\n    function updateBorrowingFee(uint256 _borrowingFee) external onlyOwner {\n        require(_borrowingFee <= MAX_BORROWING_FEE, 'Mx: value not valid');\n        emit LogBorrowingFee(borrowingFee, _borrowingFee);\n        borrowingFee = _borrowingFee;\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(address user, uint256 _exchangeRate)\n        internal\n        view\n        returns (bool)\n    {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            yieldBox.toAmount(\n                collateralId,\n                collateralShare *\n                    (EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION) *\n                    CLOSED_COLLATERIZATION_RATE,\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            (borrowPart * _totalBorrow.elastic * _exchangeRate) /\n                _totalBorrow.base;\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @dev Closed liquidations Only, 90% of extra shares goes to caller and 10% to protocol\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param swapper Contract address of the `MultiSwapper` implementation. See `setSwapper`.\n    /// @param swapData Swap necessar data\n    function _closedLiquidation(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        IMultiSwapper swapper,\n        uint256 _exchangeRate,\n        bytes calldata swapData\n    ) private {\n        uint256 allCollateralShare;\n        uint256 allBorrowAmount;\n        uint256 allBorrowPart;\n        Rebase memory _totalBorrow = totalBorrow;\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                uint256 borrowPart;\n                {\n                    uint256 availableBorrowPart = userBorrowPart[user];\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart\n                        ? availableBorrowPart\n                        : maxBorrowParts[i];\n                    userBorrowPart[user] = availableBorrowPart - borrowPart;\n                }\n                uint256 borrowAmount = _totalBorrow.toElastic(\n                    borrowPart,\n                    false\n                );\n                uint256 collateralShare = yieldBox.toShare(\n                    collateralId,\n                    (borrowAmount * LIQUIDATION_MULTIPLIER * _exchangeRate) /\n                        (LIQUIDATION_MULTIPLIER_PRECISION *\n                            EXCHANGE_RATE_PRECISION),\n                    false\n                );\n                userCollateralShare[user] -= collateralShare;\n                emit LogRemoveCollateral(\n                    user,\n                    address(swapper),\n                    collateralShare\n                );\n                emit LogRepay(address(swapper), user, borrowAmount, borrowPart);\n\n                // Keep totals\n                allCollateralShare += collateralShare;\n                allBorrowAmount += borrowAmount;\n                allBorrowPart += borrowPart;\n            }\n        }\n        require(allBorrowAmount != 0, 'Mx: solvent');\n        _totalBorrow.elastic -= uint128(allBorrowAmount);\n        _totalBorrow.base -= uint128(allBorrowPart);\n        totalBorrow = _totalBorrow;\n        totalCollateralShare -= allCollateralShare;\n\n        uint256 allBorrowShare = yieldBox.toShare(\n            assetId,\n            allBorrowAmount,\n            true\n        );\n\n        // Closed liquidation using a pre-approved swapper\n        require(beachBar.swappers(swapper), 'Mx: Invalid swapper');\n\n        // Swaps the users collateral for the borrowed asset\n        yieldBox.transfer(\n            address(this),\n            address(swapper),\n            collateralId,\n            allCollateralShare\n        );\n\n        uint256 minAssetMount = 0;\n        if (swapData.length > 0) {\n            minAssetMount = abi.decode(swapData, (uint256));\n        }\n        uint256 balanceBefore = yieldBox.balanceOf(address(this), assetId);\n        swapper.swap(\n            collateralId,\n            assetId,\n            minAssetMount,\n            address(this),\n            collateralSwapPath,\n            allCollateralShare\n        );\n        uint256 balanceAfter = yieldBox.balanceOf(address(this), assetId);\n\n        uint256 returnedShare = balanceAfter - balanceBefore;\n        uint256 extraShare = returnedShare - allBorrowShare;\n        uint256 feeShare = (extraShare * PROTOCOL_FEE) / PROTOCOL_FEE_DIVISOR; // 10% of profit goes to fee.\n        uint256 callerShare = (extraShare * CALLER_FEE) / CALLER_FEE_DIVISOR; //  90%  of profit goes to caller.\n\n        require(\n            feeShare + callerShare == extraShare,\n            'Mx: fee values not valid'\n        );\n\n        yieldBox.transfer(address(this), beachBar.feeTo(), assetId, feeShare);\n        yieldBox.transfer(address(this), msg.sender, assetId, callerShare);\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _tokenId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(\n        address from,\n        uint256 _tokenId,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        if (skim) {\n            require(\n                share <= yieldBox.balanceOf(address(this), _tokenId) - total,\n                'Mx: too much'\n            );\n        } else {\n            yieldBox.transfer(from, address(this), _tokenId, share);\n        }\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(\n        address from,\n        address to,\n        uint256 share\n    ) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address from,\n        address to,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n\n        userBorrowPart[to] -= part;\n\n        uint256 toWithdraw = (amount - part); //acrrued\n        uint256 toBurn = amount - toWithdraw;\n\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n        //burn USD0\n        if (toBurn > 0) {\n            asset.burn(address(this), toBurn);\n        }\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    //TODO: accrue fees when re-borrowing\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = (amount * borrowingFee) /\n            BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        require(\n            totalBorrowCap == 0 || totalBorrow.base <= totalBorrowCap,\n            'Mx: borrow cap reached'\n        );\n\n        userBorrowPart[from] += part;\n\n        //mint USD0\n        asset.mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        asset.approve(address(yieldBox), amount);\n        yieldBox.depositAsset(assetId, address(this), to, amount, 0);\n\n        share = yieldBox.toShare(assetId, amount, false);\n\n        emit LogBorrow(from, to, amount, feeAmount, part);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "yieldbox/contracts/AssetRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\nimport \"./interfaces/IStrategy.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\r\nimport \"./ERC1155.sol\";\r\n\r\n// An asset is a token + a strategy\r\nstruct Asset {\r\n    TokenType tokenType;\r\n    address contractAddress;\r\n    IStrategy strategy;\r\n    uint256 tokenId;\r\n}\r\n\r\ncontract AssetRegister is ERC1155 {\r\n    using BoringAddress for address;\r\n\r\n    event AssetRegistered(\r\n        TokenType indexed tokenType,\r\n        address indexed contractAddress,\r\n        IStrategy strategy,\r\n        uint256 indexed tokenId,\r\n        uint256 assetId\r\n    );\r\n\r\n    // ids start at 1 so that id 0 means it's not yet registered\r\n    mapping(TokenType => mapping(address => mapping(IStrategy => mapping(uint256 => uint256)))) public ids;\r\n    Asset[] public assets;\r\n\r\n    constructor() {\r\n        assets.push(Asset(TokenType.None, address(0), NO_STRATEGY, 0));\r\n    }\r\n\r\n    function assetCount() public view returns (uint256) {\r\n        return assets.length;\r\n    }\r\n\r\n    function _registerAsset(\r\n        TokenType tokenType,\r\n        address contractAddress,\r\n        IStrategy strategy,\r\n        uint256 tokenId\r\n    ) internal returns (uint256 assetId) {\r\n        // Checks\r\n        assetId = ids[tokenType][contractAddress][strategy][tokenId];\r\n\r\n        // If assetId is 0, this is a new asset that needs to be registered\r\n        if (assetId == 0) {\r\n            // Only do these checks if a new asset needs to be created\r\n            require(tokenId == 0 || tokenType != TokenType.ERC20, \"YieldBox: No tokenId for ERC20\");\r\n            require(\r\n                strategy == NO_STRATEGY ||\r\n                    (tokenType == strategy.tokenType() && contractAddress == strategy.contractAddress() && tokenId == strategy.tokenId()),\r\n                \"YieldBox: Strategy mismatch\"\r\n            );\r\n            // If a new token gets added, the isContract checks that this is a deployed contract. Needed for security.\r\n            // Prevents getting shares for a future token whose address is known in advance. For instance a token that will be deployed with CREATE2 in the future or while the contract creation is\r\n            // in the mempool\r\n            require((tokenType == TokenType.Native && contractAddress == address(0)) || contractAddress.isContract(), \"YieldBox: Not a token\");\r\n\r\n            // Effects\r\n            assetId = assets.length;\r\n            assets.push(Asset(tokenType, contractAddress, strategy, tokenId));\r\n            ids[tokenType][contractAddress][strategy][tokenId] = assetId;\r\n\r\n            // The actual URI isn't emitted here as per EIP1155, because that would make this call super expensive.\r\n            emit URI(\"\", assetId);\r\n            emit AssetRegistered(tokenType, contractAddress, strategy, tokenId, assetId);\r\n        }\r\n    }\r\n\r\n    function registerAsset(\r\n        TokenType tokenType,\r\n        address contractAddress,\r\n        IStrategy strategy,\r\n        uint256 tokenId\r\n    ) public returns (uint256 assetId) {\r\n        // Native assets can only be added internally by the NativeTokenFactory\r\n        require(\r\n            tokenType == TokenType.ERC20 || tokenType == TokenType.ERC721 || tokenType == TokenType.ERC1155,\r\n            \"AssetManager: cannot add Native\"\r\n        );\r\n        assetId = _registerAsset(tokenType, contractAddress, strategy, tokenId);\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/BoringMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\n\r\nlibrary BoringMath {\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= type(uint128).max, \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= type(uint64).max, \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= type(uint32).max, \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n\r\n    function muldiv(\r\n        uint256 value,\r\n        uint256 mul,\r\n        uint256 div,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 result) {\r\n        result = (value * mul) / div;\r\n        if (roundUp && (result * div) / mul < value) {\r\n            result++;\r\n        }\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/enums/YieldBoxTokenType.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/// @title TokenType\r\n/// @author BoringCrypto (@Boring_Crypto)\r\n/// @notice The YieldBox can hold different types of tokens:\r\n/// Native: These are ERC1155 tokens native to YieldBox. Protocols using YieldBox should use these is possible when simple token creation is needed.\r\n/// ERC20: ERC20 tokens (including rebasing tokens) can be added to the YieldBox.\r\n/// ERC1155: ERC1155 tokens are also supported. This can also be used to add YieldBox Native tokens to strategies since they are ERC1155 tokens.\r\nenum TokenType {\r\n    Native,\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155,\r\n    None\r\n}\r\n"
    },
    "yieldbox/contracts/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\n\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155TokenReceiver.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\r\n\r\n// Written by OreNoMochi (https://github.com/OreNoMochii), BoringCrypto\r\n\r\ncontract ERC1155 is IERC1155 {\r\n    using BoringAddress for address;\r\n\r\n    // mappings\r\n    mapping(address => mapping(address => bool)) public override isApprovedForAll; // map of operator approval\r\n    mapping(address => mapping(uint256 => uint256)) public override balanceOf; // map of tokens owned by\r\n    mapping(uint256 => uint256) public totalSupply; // totalSupply per token\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\r\n        return\r\n            interfaceID == this.supportsInterface.selector || // EIP-165\r\n            interfaceID == 0xd9b67a26 || // ERC-1155\r\n            interfaceID == 0x0e89341c; // EIP-1155 Metadata\r\n    }\r\n\r\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view override returns (uint256[] memory balances) {\r\n        uint256 len = owners.length;\r\n        require(len == ids.length, \"ERC1155: Length mismatch\");\r\n\r\n        balances = new uint256[](len);\r\n\r\n        for (uint256 i = 0; i < len; i++) {\r\n            balances[i] = balanceOf[owners[i]][ids[i]];\r\n        }\r\n    }\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 value\r\n    ) internal {\r\n        require(to != address(0), \"No 0 address\");\r\n\r\n        balanceOf[to][id] += value;\r\n        totalSupply[id] += value;\r\n\r\n        emit TransferSingle(msg.sender, address(0), to, id, value);\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 value\r\n    ) internal {\r\n        require(from != address(0), \"No 0 address\");\r\n\r\n        balanceOf[from][id] -= value;\r\n        totalSupply[id] -= value;\r\n\r\n        emit TransferSingle(msg.sender, from, address(0), id, value);\r\n    }\r\n\r\n    function _transferSingle(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 value\r\n    ) internal {\r\n        require(to != address(0), \"No 0 address\");\r\n\r\n        balanceOf[from][id] -= value;\r\n        balanceOf[to][id] += value;\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, value);\r\n    }\r\n\r\n    function _transferBatch(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values\r\n    ) internal {\r\n        require(to != address(0), \"No 0 address\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 value = values[i];\r\n            balanceOf[from][id] -= value;\r\n            balanceOf[to][id] += value;\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, to, ids, values);\r\n    }\r\n\r\n    function _requireTransferAllowed(address from) internal view virtual {\r\n        require(from == msg.sender || isApprovedForAll[from][msg.sender] == true, \"Transfer not allowed\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override {\r\n        _requireTransferAllowed(from);\r\n\r\n        _transferSingle(from, to, id, value);\r\n\r\n        if (to.isContract()) {\r\n            require(\r\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, value, data) ==\r\n                    bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")),\r\n                \"Wrong return value\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override {\r\n        require(ids.length == values.length, \"ERC1155: Length mismatch\");\r\n        _requireTransferAllowed(from);\r\n\r\n        _transferBatch(from, to, ids, values);\r\n\r\n        if (to.isContract()) {\r\n            require(\r\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, values, data) ==\r\n                    bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")),\r\n                \"Wrong return value\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) external virtual override {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function uri(\r\n        uint256 /*assetId*/\r\n    ) external view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/ERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155TokenReceiver.sol\";\r\n\r\ncontract ERC1155TokenReceiver is IERC1155TokenReceiver {\r\n    // ERC1155 receivers that simple accept the transfer\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return 0xf23a6e61; //bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return 0xbc197c81; //bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../enums/YieldBoxTokenType.sol\";\r\nimport \"./IYieldBox.sol\";\r\n\r\ninterface IStrategy {\r\n    /// Each strategy only works with a single asset. This should help make implementations simpler and more readable.\r\n    /// To safe gas a proxy pattern (YieldBox factory) could be used to deploy the same strategy for multiple tokens.\r\n\r\n    /// It is recommended that strategies keep a small amount of funds uninvested (like 5%) to handle small withdrawals\r\n    /// and deposits without triggering costly investing/divesting logic.\r\n\r\n    /// #########################\r\n    /// ### Basic Information ###\r\n    /// #########################\r\n\r\n    /// Returns the address of the yieldBox that this strategy is for\r\n    function yieldBox() external view returns (IYieldBox yieldBox_);\r\n\r\n    /// Returns a name for this strategy\r\n    function name() external view returns (string memory name_);\r\n\r\n    /// Returns a description for this strategy\r\n    function description() external view returns (string memory description_);\r\n\r\n    /// #######################\r\n    /// ### Supported Token ###\r\n    /// #######################\r\n\r\n    /// Returns the standard that this strategy works with\r\n    function tokenType() external view returns (TokenType tokenType_);\r\n\r\n    /// Returns the contract address that this strategy works with\r\n    function contractAddress() external view returns (address contractAddress_);\r\n\r\n    /// Returns the tokenId that this strategy works with (for EIP1155)\r\n    /// This is always 0 for EIP20 tokens\r\n    function tokenId() external view returns (uint256 tokenId_);\r\n\r\n    /// ###########################\r\n    /// ### Balance Information ###\r\n    /// ###########################\r\n\r\n    /// Returns the total value the strategy holds (principle + gain) expressed in asset token amount.\r\n    /// This should be cheap in gas to retrieve. Can return a bit less than the actual, but MUST NOT return more.\r\n    /// The gas cost of this function will be paid on any deposit or withdrawal onto and out of the YieldBox\r\n    /// that uses this strategy. Also, anytime a protocol converts between shares and amount, this gets called.\r\n    function currentBalance() external view returns (uint256 amount);\r\n\r\n    /// Returns the maximum amount that can be withdrawn\r\n    function withdrawable() external view returns (uint256 amount);\r\n\r\n    /// Returns the maximum amount that can be withdrawn for a low gas fee\r\n    /// When more than this amount is withdrawn it will trigger divesting from the actual strategy\r\n    /// which will incur higher gas costs\r\n    function cheapWithdrawable() external view returns (uint256 amount);\r\n\r\n    /// ##########################\r\n    /// ### YieldBox Functions ###\r\n    /// ##########################\r\n\r\n    /// Is called by YieldBox to signal funds have been added, the strategy may choose to act on this\r\n    /// When a large enough deposit is made, this should trigger the strategy to invest into the actual\r\n    /// strategy. This function should normally NOT be used to invest on each call as that would be costly\r\n    /// for small deposits.\r\n    /// If the strategy handles native tokens (ETH) it will receive it directly (not wrapped). It will be\r\n    /// up to the strategy to wrap it if needed.\r\n    /// Only accept this call from the YieldBox\r\n    function deposited(uint256 amount) external;\r\n\r\n    /// Is called by the YieldBox to ask the strategy to withdraw to the user\r\n    /// When a strategy keeps a little reserve for cheap withdrawals and the requested withdrawal goes over this amount,\r\n    /// the strategy should divest enough from the strategy to complete the withdrawal and rebalance the reserve.\r\n    /// If the strategy handles native tokens (ETH) it should send this, not a wrapped version.\r\n    /// With some strategies it might be hard to withdraw exactly the correct amount.\r\n    /// Only accept this call from the YieldBox\r\n    function withdraw(address to, uint256 amount) external;\r\n}\r\n\r\nIStrategy constant NO_STRATEGY = IStrategy(address(0));\r\n"
    },
    "yieldbox/contracts/interfaces/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\r\n\r\ninterface IWrappedNative is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "yieldbox/contracts/interfaces/IYieldBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../enums/YieldBoxTokenType.sol\";\r\n\r\ninterface IYieldBox {\r\n    function wrappedNative() external view returns (address wrappedNative);\r\n\r\n    function assets(uint256 assetId)\r\n        external\r\n        view\r\n        returns (\r\n            TokenType tokenType,\r\n            address contractAddress,\r\n            address strategy,\r\n            uint256 tokenId\r\n        );\r\n\r\n    function nativeTokens(uint256 assetId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            string memory symbol,\r\n            uint8 decimals\r\n        );\r\n\r\n    function owner(uint256 assetId) external view returns (address owner);\r\n\r\n    function totalSupply(uint256 assetId) external view returns (uint256 totalSupply);\r\n\r\n    function depositAsset(\r\n        uint256 assetId,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function withdraw(\r\n        uint256 assetId,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function transfer(\r\n        address from,\r\n        address to,\r\n        uint256 assetId,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function batchTransfer(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata assetIds_,\r\n        uint256[] calldata shares_\r\n    ) external;\r\n\r\n    function transferMultiple(\r\n        address from,\r\n        address[] calldata tos,\r\n        uint256 assetId,\r\n        uint256[] calldata shares\r\n    ) external;\r\n\r\n    function toShare(\r\n        uint256 assetId,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n\r\n    function toAmount(\r\n        uint256 assetId,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n}\r\n"
    },
    "yieldbox/contracts/NativeTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\nimport \"./AssetRegister.sol\";\r\nimport \"./BoringMath.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\r\n\r\nstruct NativeToken {\r\n    string name;\r\n    string symbol;\r\n    uint8 decimals;\r\n    string uri;\r\n}\r\n\r\n/// @title NativeTokenFactory\r\n/// @author BoringCrypto (@Boring_Crypto)\r\n/// @notice The NativeTokenFactory is a token factory to create ERC1155 tokens. This is used by YieldBox to create\r\n/// native tokens in YieldBox. These have many benefits:\r\n/// - low and predictable gas usage\r\n/// - simplified approval\r\n/// - no hidden features, all these tokens behave the same\r\n/// TODO: MintBatch? BurnBatch?\r\ncontract NativeTokenFactory is AssetRegister, BoringFactory {\r\n    using BoringMath for uint256;\r\n\r\n    mapping(uint256 => NativeToken) public nativeTokens;\r\n    mapping(uint256 => address) public owner;\r\n    mapping(uint256 => address) public pendingOwner;\r\n\r\n    event TokenCreated(address indexed creator, string name, string symbol, uint8 decimals, uint256 tokenId);\r\n    event OwnershipTransferred(uint256 indexed tokenId, address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ***************** //\r\n    // *** MODIFIERS *** //\r\n    // ***************** //\r\n\r\n    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.\r\n    /// If 'from' is msg.sender, it's allowed.\r\n    /// If 'msg.sender' is an address (an operator) that is approved by 'from', it's allowed.\r\n    /// If 'msg.sender' is a clone of a masterContract that is approved by 'from', it's allowed.\r\n    modifier allowed(address from) {\r\n        if (from != msg.sender && !isApprovedForAll[from][msg.sender]) {\r\n            address masterContract = masterContractOf[msg.sender];\r\n            require(masterContract != address(0) && isApprovedForAll[from][masterContract], \"YieldBox: Not approved\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allows the `owner` to execute the function.\r\n    /// @param tokenId The `tokenId` that the sender has to be owner of.\r\n    modifier onlyOwner(uint256 tokenId) {\r\n        require(msg.sender == owner[tokenId], \"NTF: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n    /// Can only be invoked by the current `owner`.\r\n    /// @param tokenId The `tokenId` of the token that ownership whose ownership will be transferred/renounced.\r\n    /// @param newOwner Address of the new owner.\r\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\r\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\r\n    function transferOwnership(\r\n        uint256 tokenId,\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) public onlyOwner(tokenId) {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"NTF: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(tokenId, owner[tokenId], newOwner);\r\n            owner[tokenId] = newOwner;\r\n            pendingOwner[tokenId] = address(0);\r\n        } else {\r\n            // Effects\r\n            pendingOwner[tokenId] = newOwner;\r\n        }\r\n    }\r\n\r\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\r\n    /// @param tokenId The `tokenId` of the token that ownership is claimed for.\r\n    function claimOwnership(uint256 tokenId) public {\r\n        address _pendingOwner = pendingOwner[tokenId];\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"NTF: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(tokenId, owner[tokenId], _pendingOwner);\r\n        owner[tokenId] = _pendingOwner;\r\n        pendingOwner[tokenId] = address(0);\r\n    }\r\n\r\n    /// @notice Create a new native token. This will be an ERC1155 token. If later it's needed as an ERC20 token it can\r\n    /// be wrapped into an ERC20 token. Native support for ERC1155 tokens is growing though.\r\n    /// @param name The name of the token.\r\n    /// @param symbol The symbol of the token.\r\n    /// @param decimals The number of decimals of the token (this is just for display purposes). Should be set to 18 in normal cases.\r\n    function createToken(\r\n        string calldata name,\r\n        string calldata symbol,\r\n        uint8 decimals,\r\n        string calldata uri\r\n    ) public returns (uint32 tokenId) {\r\n        // To keep each Token unique in the AssetRegister, we use the assetId as the tokenId. So for native assets, the tokenId is always equal to the assetId.\r\n        tokenId = assets.length.to32();\r\n        _registerAsset(TokenType.Native, address(0), NO_STRATEGY, tokenId);\r\n        // Initial supply is 0, use owner can mint. For a fixed supply the owner can mint and revoke ownership.\r\n        // The msg.sender is the initial owner, can be changed after.\r\n        nativeTokens[tokenId] = NativeToken(name, symbol, decimals, uri);\r\n        owner[tokenId] = msg.sender;\r\n\r\n        emit TokenCreated(msg.sender, name, symbol, decimals, tokenId);\r\n        emit TransferSingle(msg.sender, address(0), address(0), tokenId, 0);\r\n        emit OwnershipTransferred(tokenId, address(0), msg.sender);\r\n    }\r\n\r\n    /// @notice The `owner` can mint tokens. If a fixed supply is needed, the `owner` should mint the totalSupply and renounce ownership.\r\n    /// @param tokenId The token to be minted.\r\n    /// @param to The account to transfer the minted tokens to.\r\n    /// @param amount The amount of tokens to mint.\r\n    function mint(\r\n        uint256 tokenId,\r\n        address to,\r\n        uint256 amount\r\n    ) public onlyOwner(tokenId) {\r\n        _mint(to, tokenId, amount);\r\n    }\r\n\r\n    /// @notice Burns tokens. Only the holder of tokens can burn them.\r\n    /// @param tokenId The token to be burned.\r\n    /// @param amount The amount of tokens to burn.\r\n    function burn(\r\n        uint256 tokenId,\r\n        address from,\r\n        uint256 amount\r\n    ) public allowed(from) {\r\n        require(assets[tokenId].tokenType == TokenType.Native, \"NTF: Not native\");\r\n        _burn(msg.sender, tokenId, amount);\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"../enums/YieldBoxTokenType.sol\";\r\nimport \"../interfaces/IStrategy.sol\";\r\n\r\n// solhint-disable const-name-snakecase\r\n// solhint-disable no-empty-blocks\r\n\r\nabstract contract BaseStrategy is IStrategy {\r\n    IYieldBox public immutable yieldBox;\r\n\r\n    constructor(IYieldBox _yieldBox) {\r\n        yieldBox = _yieldBox;\r\n    }\r\n\r\n    function _currentBalance() internal view virtual returns (uint256 amount);\r\n\r\n    function currentBalance() public view virtual returns (uint256 amount) {\r\n        return _currentBalance();\r\n    }\r\n\r\n    function withdrawable() external view virtual returns (uint256 amount) {\r\n        return _currentBalance();\r\n    }\r\n\r\n    function cheapWithdrawable() external view virtual returns (uint256 amount) {\r\n        return _currentBalance();\r\n    }\r\n\r\n    function _deposited(uint256 amount) internal virtual;\r\n\r\n    function deposited(uint256 amount) external {\r\n        require(msg.sender == address(yieldBox), \"Not YieldBox\");\r\n        _deposited(amount);\r\n    }\r\n\r\n    function _withdraw(address to, uint256 amount) internal virtual;\r\n\r\n    function withdraw(address to, uint256 amount) external {\r\n        require(msg.sender == address(yieldBox), \"Not YieldBox\");\r\n        _withdraw(to, amount);\r\n    }\r\n}\r\n\r\nabstract contract BaseERC20Strategy is BaseStrategy {\r\n    TokenType public constant tokenType = TokenType.ERC20;\r\n    uint256 public constant tokenId = 0;\r\n    address public immutable contractAddress;\r\n\r\n    constructor(IYieldBox _yieldBox, address _contractAddress) BaseStrategy(_yieldBox) {\r\n        contractAddress = _contractAddress;\r\n    }\r\n}\r\n\r\nabstract contract BaseERC1155Strategy is BaseStrategy {\r\n    TokenType public constant tokenType = TokenType.ERC1155;\r\n    uint256 public immutable tokenId;\r\n    address public immutable contractAddress;\r\n\r\n    constructor(\r\n        IYieldBox _yieldBox,\r\n        address _contractAddress,\r\n        uint256 _tokenId\r\n    ) BaseStrategy(_yieldBox) {\r\n        contractAddress = _contractAddress;\r\n        tokenId = _tokenId;\r\n    }\r\n}\r\n\r\nabstract contract BaseNativeStrategy is BaseStrategy {\r\n    TokenType public constant tokenType = TokenType.Native;\r\n    uint256 public immutable tokenId;\r\n    address public constant contractAddress = address(0);\r\n\r\n    constructor(IYieldBox _yieldBox, uint256 _tokenId) BaseStrategy(_yieldBox) {\r\n        tokenId = _tokenId;\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/YieldBox.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// The YieldBox\r\n// The original BentoBox is owned by the Sushi team to set strategies for each token. Abracadabra wanted different strategies, which led to\r\n// them launching their own DegenBox. The YieldBox solves this by allowing an unlimited number of strategies for each token in a fully\r\n// permissionless manner. The YieldBox has no owner and operates fully permissionless.\r\n\r\n// Other improvements:\r\n// Better system to make sure the token to share ratio doesn't reset.\r\n// Full support for rebasing tokens.\r\n\r\n// This contract stores funds, handles their transfers, approvals and strategies.\r\n\r\n// Copyright (c) 2021, 2022 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Since the contract is permissionless, only one deployment per chain is needed. If it's not yet deployed\r\n// on a chain or if you want to make a derivative work, contact @BoringCrypto. The core of YieldBox is\r\n// copyrighted. Most of the contracts that it builds on are open source though.\r\n\r\n// BEWARE: Still under active development\r\n// Security review not done yet\r\n\r\npragma solidity ^0.8.9;\r\npragma experimental ABIEncoderV2;\r\nimport \"./interfaces/IWrappedNative.sol\";\r\nimport \"./interfaces/IStrategy.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC721.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\r\nimport \"./ERC1155TokenReceiver.sol\";\r\nimport \"./ERC1155.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"./AssetRegister.sol\";\r\nimport \"./NativeTokenFactory.sol\";\r\nimport \"./YieldBoxRebase.sol\";\r\nimport \"./YieldBoxURIBuilder.sol\";\r\n\r\n// solhint-disable no-empty-blocks\r\n\r\n/// @title YieldBox\r\n/// @author BoringCrypto, Keno\r\n/// @notice The YieldBox is a vault for tokens. The stored tokens can assigned to strategies.\r\n/// Yield from this will go to the token depositors.\r\n/// Any funds transfered directly onto the YieldBox will be lost, use the deposit function instead.\r\ncontract YieldBox is BoringBatchable, NativeTokenFactory, ERC1155TokenReceiver {\r\n    using BoringAddress for address;\r\n    using BoringERC20 for IERC20;\r\n    using BoringERC20 for IWrappedNative;\r\n    using YieldBoxRebase for uint256;\r\n\r\n    // ************** //\r\n    // *** EVENTS *** //\r\n    // ************** //\r\n\r\n    // TODO: Add events\r\n\r\n    // ******************* //\r\n    // *** CONSTRUCTOR *** //\r\n    // ******************* //\r\n\r\n    IWrappedNative public immutable wrappedNative;\r\n    YieldBoxURIBuilder public immutable uriBuilder;\r\n\r\n    constructor(IWrappedNative wrappedNative_, YieldBoxURIBuilder uriBuilder_) {\r\n        wrappedNative = wrappedNative_;\r\n        uriBuilder = uriBuilder_;\r\n    }\r\n\r\n    // ************************** //\r\n    // *** INTERNAL FUNCTIONS *** //\r\n    // ************************** //\r\n\r\n    /// @dev Returns the total balance of `token` this contracts holds,\r\n    /// plus the total amount this contract thinks the strategy holds.\r\n    function _tokenBalanceOf(Asset storage asset) internal view returns (uint256 amount) {\r\n        if (asset.strategy == NO_STRATEGY) {\r\n            if (asset.tokenType == TokenType.ERC20) {\r\n                return IERC20(asset.contractAddress).safeBalanceOf(address(this));\r\n            } else {\r\n                return IERC1155(asset.contractAddress).balanceOf(address(this), asset.tokenId);\r\n            }\r\n        } else {\r\n            return asset.strategy.currentBalance();\r\n        }\r\n    }\r\n\r\n    // ************************ //\r\n    // *** PUBLIC FUNCTIONS *** //\r\n    // ************************ //\r\n\r\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\r\n    /// @param assetId The id of the asset.\r\n    /// @param from which account to pull the tokens.\r\n    /// @param to which account to push the tokens.\r\n    /// @param amount Token amount in native representation to deposit.\r\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\r\n    /// @return amountOut The amount deposited.\r\n    /// @return shareOut The deposited amount repesented in shares.\r\n    function depositAsset(\r\n        uint256 assetId,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\r\n        // Checks\r\n        Asset storage asset = assets[assetId];\r\n        require(asset.tokenType != TokenType.Native, \"YieldBox: can't deposit Native\");\r\n        require(asset.tokenType != TokenType.ERC721, \"YieldBox: use DepositNFT\");\r\n\r\n        // Effects\r\n        uint256 totalAmount = _tokenBalanceOf(asset);\r\n        if (share == 0) {\r\n            // value of the share may be lower than the amount due to rounding, that's ok\r\n            share = amount._toShares(totalSupply[assetId], totalAmount, false);\r\n        } else {\r\n            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)\r\n            amount = share._toAmount(totalSupply[assetId], totalAmount, true);\r\n        }\r\n\r\n        _mint(to, assetId, share);\r\n\r\n        address destination = asset.strategy == NO_STRATEGY ? address(this) : address(asset.strategy);\r\n\r\n        // Interactions\r\n        if (asset.tokenType == TokenType.ERC20) {\r\n            IERC20(asset.contractAddress).safeTransferFrom(from, destination, amount);\r\n        } else {\r\n            // ERC1155\r\n            // When depositing yieldBox tokens into the yieldBox, things can be simplified\r\n            if (asset.contractAddress == address(this)) {\r\n                _transferSingle(from, destination, asset.tokenId, amount);\r\n            } else {\r\n                IERC1155(asset.contractAddress).safeTransferFrom(from, destination, asset.tokenId, amount, \"\");\r\n            }\r\n        }\r\n\r\n        if (asset.strategy != NO_STRATEGY) {\r\n            asset.strategy.deposited(amount);\r\n        }\r\n\r\n        return (amount, share);\r\n    }\r\n\r\n    /// @notice Deposit an NFT asset\r\n    /// @param assetId The id of the asset.\r\n    /// @param from which account to pull the tokens.\r\n    /// @param to which account to push the tokens.\r\n    /// @return amountOut The amount deposited.\r\n    /// @return shareOut The deposited amount repesented in shares.\r\n    function depositNFTAsset(\r\n        uint256 assetId,\r\n        address from,\r\n        address to\r\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\r\n        // Checks\r\n        Asset storage asset = assets[assetId];\r\n        require(asset.tokenType == TokenType.ERC721, \"YieldBox: not ERC721\");\r\n\r\n        // Effects\r\n        _mint(to, assetId, 1);\r\n\r\n        address destination = asset.strategy == NO_STRATEGY ? address(this) : address(asset.strategy);\r\n\r\n        // Interactions\r\n        IERC721(asset.contractAddress).safeTransferFrom(from, destination, asset.tokenId);\r\n\r\n        if (asset.strategy != NO_STRATEGY) {\r\n            asset.strategy.deposited(1);\r\n        }\r\n\r\n        return (1, 1);\r\n    }\r\n\r\n    function depositETHAsset(\r\n        uint256 assetId,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        public\r\n        payable\r\n        returns (\r\n            // TODO: allow shares with refund?\r\n            uint256 amountOut,\r\n            uint256 shareOut\r\n        )\r\n    {\r\n        // Checks\r\n        Asset storage asset = assets[assetId];\r\n        require(asset.tokenType == TokenType.ERC20 && asset.contractAddress == address(wrappedNative), \"YieldBox: not wrappedNative\");\r\n\r\n        // Effects\r\n        uint256 share = amount._toShares(totalSupply[assetId], _tokenBalanceOf(asset), false);\r\n\r\n        _mint(to, assetId, share);\r\n\r\n        // Interactions\r\n        wrappedNative.deposit{ value: amount }();\r\n        if (asset.strategy != NO_STRATEGY) {\r\n            // Strategies always receive wrappedNative (supporting both wrapped and raw native tokens adds too much complexity)\r\n            wrappedNative.safeTransfer(address(asset.strategy), amount);\r\n        }\r\n\r\n        if (asset.strategy != NO_STRATEGY) {\r\n            asset.strategy.deposited(amount);\r\n        }\r\n\r\n        return (amount, share);\r\n    }\r\n\r\n    /// @notice Withdraws an amount of `token` from a user account.\r\n    /// @param assetId The id of the asset.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param to which user to push the tokens.\r\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\r\n    /// @param share Like above, but `share` takes precedence over `amount`.\r\n    function withdraw(\r\n        uint256 assetId,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\r\n        // Checks\r\n        Asset storage asset = assets[assetId];\r\n        require(asset.tokenType != TokenType.Native, \"YieldBox: can't withdraw Native\");\r\n\r\n        // Effects\r\n        uint256 totalAmount = _tokenBalanceOf(asset);\r\n        if (share == 0) {\r\n            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)\r\n            share = amount._toShares(totalSupply[assetId], totalAmount, true);\r\n        } else {\r\n            // amount may be lower than the value of share due to rounding, that's ok\r\n            amount = share._toAmount(totalSupply[assetId], totalAmount, false);\r\n        }\r\n\r\n        _burn(from, assetId, share);\r\n\r\n        // Interactions\r\n        if (asset.strategy == NO_STRATEGY) {\r\n            if (asset.tokenType == TokenType.ERC20) {\r\n                // Native tokens are always unwrapped when withdrawn\r\n                if (asset.contractAddress == address(wrappedNative)) {\r\n                    wrappedNative.withdraw(amount);\r\n                    to.sendNative(amount);\r\n                } else {\r\n                    IERC20(asset.contractAddress).safeTransfer(to, amount);\r\n                }\r\n            } else if (asset.tokenType == TokenType.ERC721) {\r\n                IERC721(asset.contractAddress).safeTransferFrom(address(this), to, asset.tokenId);\r\n            } else {\r\n                // IERC1155\r\n                IERC1155(asset.contractAddress).safeTransferFrom(address(this), to, asset.tokenId, amount, \"\");\r\n            }\r\n        } else {\r\n            asset.strategy.withdraw(to, amount);\r\n        }\r\n\r\n        return (amount, share);\r\n    }\r\n\r\n    function _requireTransferAllowed(address from) internal view override allowed(from) {}\r\n\r\n    /// @notice Transfer shares from a user account to another one.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param to which user to push the tokens.\r\n    /// @param assetId The id of the asset.\r\n    /// @param share The amount of `token` in shares.\r\n    function transfer(\r\n        address from,\r\n        address to,\r\n        uint256 assetId,\r\n        uint256 share\r\n    ) public allowed(from) {\r\n        _transferSingle(from, to, assetId, share);\r\n    }\r\n\r\n    function batchTransfer(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata assetIds_,\r\n        uint256[] calldata shares_\r\n    ) public allowed(from) {\r\n        _transferBatch(from, to, assetIds_, shares_);\r\n    }\r\n\r\n    /// @notice Transfer shares from a user account to multiple other ones.\r\n    /// @param assetId The id of the asset.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param tos The receivers of the tokens.\r\n    /// @param shares The amount of `token` in shares for each receiver in `tos`.\r\n    function transferMultiple(\r\n        address from,\r\n        address[] calldata tos,\r\n        uint256 assetId,\r\n        uint256[] calldata shares\r\n    ) public allowed(from) {\r\n        // Checks\r\n        uint256 len = tos.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            require(tos[i] != address(0), \"YieldBox: to not set\"); // To avoid a bad UI from burning funds\r\n        }\r\n\r\n        // Effects\r\n        uint256 totalAmount;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address to = tos[i];\r\n            uint256 share_ = shares[i];\r\n            balanceOf[to][assetId] += share_;\r\n            totalAmount += share_;\r\n            emit TransferSingle(msg.sender, from, to, assetId, share_);\r\n        }\r\n        balanceOf[from][assetId] -= totalAmount;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) external override {\r\n        // Checks\r\n        require(operator != address(0), \"YieldBox: operator not set\"); // Important for security\r\n        require(masterContractOf[msg.sender] == address(0), \"YieldBox: user is clone\");\r\n        require(operator != address(this), \"YieldBox: can't approve yieldBox\");\r\n\r\n        // Effects\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    // This functionality has been split off into a separate contract. This is only a view function, so gas usage isn't a huge issue.\r\n    // This keeps the YieldBox contract smaller, so it can be optimized more.\r\n    function uri(uint256 assetId) external view override returns (string memory) {\r\n        return uriBuilder.uri(assets[assetId], nativeTokens[assetId], totalSupply[assetId], owner[assetId]);\r\n    }\r\n\r\n    function name(uint256 assetId) external view returns (string memory) {\r\n        return uriBuilder.name(assets[assetId], nativeTokens[assetId].name);\r\n    }\r\n\r\n    function symbol(uint256 assetId) external view returns (string memory) {\r\n        return uriBuilder.symbol(assets[assetId], nativeTokens[assetId].symbol);\r\n    }\r\n\r\n    function decimals(uint256 assetId) external view returns (uint8) {\r\n        return uriBuilder.decimals(assets[assetId], nativeTokens[assetId].decimals);\r\n    }\r\n\r\n    // Included to support unwrapping wrapped native tokens such as WETH\r\n    receive() external payable {}\r\n\r\n    // Helper functions\r\n\r\n    function assetTotals(uint256 assetId) external view returns (uint256 totalShare, uint256 totalAmount) {\r\n        totalShare = totalSupply[assetId];\r\n        totalAmount = _tokenBalanceOf(assets[assetId]);\r\n    }\r\n\r\n    /// @dev Helper function to represent an `amount` of `token` in shares.\r\n    /// @param assetId The id of the asset.\r\n    /// @param amount The `token` amount.\r\n    /// @param roundUp If the result `share` should be rounded up.\r\n    /// @return share The token amount represented in shares.\r\n    function toShare(\r\n        uint256 assetId,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share) {\r\n        if (assets[assetId].tokenType == TokenType.Native || assets[assetId].tokenType == TokenType.ERC721) {\r\n            share = amount;\r\n        } else {\r\n            share = amount._toShares(totalSupply[assetId], _tokenBalanceOf(assets[assetId]), roundUp);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper function represent shares back into the `token` amount.\r\n    /// @param assetId The id of the asset.\r\n    /// @param share The amount of shares.\r\n    /// @param roundUp If the result should be rounded up.\r\n    /// @return amount The share amount back into native representation.\r\n    function toAmount(\r\n        uint256 assetId,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount) {\r\n        if (assets[assetId].tokenType == TokenType.Native || assets[assetId].tokenType == TokenType.ERC721) {\r\n            amount = share;\r\n        } else {\r\n            amount = share._toAmount(totalSupply[assetId], _tokenBalanceOf(assets[assetId]), roundUp);\r\n        }\r\n    }\r\n\r\n    /// @dev Helper function represent the balance in `token` amount for a `user` for an `asset`.\r\n    /// @param user The `user` to get the amount for.\r\n    /// @param assetId The id of the asset.\r\n    function amountOf(address user, uint256 assetId) external view returns (uint256 amount) {\r\n        if (assets[assetId].tokenType == TokenType.Native || assets[assetId].tokenType == TokenType.ERC721) {\r\n            amount = balanceOf[user][assetId];\r\n        } else {\r\n            amount = balanceOf[user][assetId]._toAmount(totalSupply[assetId], _tokenBalanceOf(assets[assetId]), false);\r\n        }\r\n    }\r\n\r\n    function deposit(\r\n        TokenType tokenType,\r\n        address contractAddress,\r\n        IStrategy strategy,\r\n        uint256 tokenId,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) public returns (uint256 amountOut, uint256 shareOut) {\r\n        if (tokenType == TokenType.Native) {\r\n            // If native token, register it as an ERC1155 asset (as that's what it is)\r\n            return depositAsset(registerAsset(TokenType.ERC1155, address(this), strategy, tokenId), from, to, amount, share);\r\n        } else {\r\n            return depositAsset(registerAsset(tokenType, contractAddress, strategy, tokenId), from, to, amount, share);\r\n        }\r\n    }\r\n\r\n    function depositETH(\r\n        IStrategy strategy,\r\n        address to,\r\n        uint256 amount\r\n    ) public payable returns (uint256 amountOut, uint256 shareOut) {\r\n        return depositETHAsset(registerAsset(TokenType.ERC20, address(wrappedNative), strategy, 0), to, amount);\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/YieldBoxRebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.9;\r\npragma experimental ABIEncoderV2;\r\nimport \"./interfaces/IStrategy.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC1155.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\r\nimport \"./ERC1155TokenReceiver.sol\";\r\nimport \"./ERC1155.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\r\n\r\nlibrary YieldBoxRebase {\r\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\r\n    function _toShares(\r\n        uint256 amount,\r\n        uint256 totalShares_,\r\n        uint256 totalAmount,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 share) {\r\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\r\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\r\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\r\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\r\n        totalAmount++;\r\n        totalShares_ += 1e8;\r\n\r\n        // Calculte the shares using te current amount to share ratio\r\n        share = (amount * totalShares_) / totalAmount;\r\n\r\n        // Default is to round down (Solidity), round up if required\r\n        if (roundUp && (share * totalAmount) / totalShares_ < amount) {\r\n            share++;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\r\n    function _toAmount(\r\n        uint256 share,\r\n        uint256 totalShares_,\r\n        uint256 totalAmount,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 amount) {\r\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\r\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\r\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\r\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\r\n        totalAmount++;\r\n        totalShares_ += 1e8;\r\n\r\n        // Calculte the amount using te current amount to share ratio\r\n        amount = (share * totalAmount) / totalShares_;\r\n\r\n        // Default is to round down (Solidity), round up if required\r\n        if (roundUp && (amount * totalShares_) / totalAmount < share) {\r\n            amount++;\r\n        }\r\n    }\r\n}\r\n"
    },
    "yieldbox/contracts/YieldBoxURIBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"./interfaces/IYieldBox.sol\";\r\nimport \"./NativeTokenFactory.sol\";\r\n\r\n// solhint-disable quotes\r\n\r\ncontract YieldBoxURIBuilder {\r\n    using BoringERC20 for IERC20;\r\n    using Strings for uint256;\r\n    using Base64 for bytes;\r\n\r\n    struct AssetDetails {\r\n        string tokenType;\r\n        string name;\r\n        string symbol;\r\n        uint256 decimals;\r\n    }\r\n\r\n    function name(Asset calldata asset, string calldata nativeName) external view returns (string memory) {\r\n        if (asset.strategy == NO_STRATEGY) {\r\n            if (asset.tokenType == TokenType.ERC20) {\r\n                IERC20 token = IERC20(asset.contractAddress);\r\n                return token.safeName();\r\n            } else if (asset.tokenType == TokenType.ERC1155) {\r\n                return\r\n                    string(abi.encodePacked(\"ERC1155:\", uint256(uint160(asset.contractAddress)).toHexString(20), \"/\", asset.tokenId.toString()));\r\n            } else {\r\n                return nativeName;\r\n            }\r\n        } else {\r\n            if (asset.tokenType == TokenType.ERC20) {\r\n                IERC20 token = IERC20(asset.contractAddress);\r\n                return string(abi.encodePacked(token.safeName(), \" (\", asset.strategy.name(), \")\"));\r\n            } else if (asset.tokenType == TokenType.ERC1155) {\r\n                return\r\n                    string(\r\n                        abi.encodePacked(\r\n                            string(\r\n                                abi.encodePacked(\r\n                                    \"ERC1155:\",\r\n                                    uint256(uint160(asset.contractAddress)).toHexString(20),\r\n                                    \"/\",\r\n                                    asset.tokenId.toString()\r\n                                )\r\n                            ),\r\n                            \" (\",\r\n                            asset.strategy.name(),\r\n                            \")\"\r\n                        )\r\n                    );\r\n            } else {\r\n                return string(abi.encodePacked(nativeName, \" (\", asset.strategy.name(), \")\"));\r\n            }\r\n        }\r\n    }\r\n\r\n    function symbol(Asset calldata asset, string calldata nativeSymbol) external view returns (string memory) {\r\n        if (asset.strategy == NO_STRATEGY) {\r\n            if (asset.tokenType == TokenType.ERC20) {\r\n                IERC20 token = IERC20(asset.contractAddress);\r\n                return token.safeSymbol();\r\n            } else if (asset.tokenType == TokenType.ERC1155) {\r\n                return \"ERC1155\";\r\n            } else {\r\n                return nativeSymbol;\r\n            }\r\n        } else {\r\n            if (asset.tokenType == TokenType.ERC20) {\r\n                IERC20 token = IERC20(asset.contractAddress);\r\n                return string(abi.encodePacked(token.safeSymbol(), \" (\", asset.strategy.name(), \")\"));\r\n            } else if (asset.tokenType == TokenType.ERC1155) {\r\n                return string(abi.encodePacked(\"ERC1155\", \" (\", asset.strategy.name(), \")\"));\r\n            } else {\r\n                return string(abi.encodePacked(nativeSymbol, \" (\", asset.strategy.name(), \")\"));\r\n            }\r\n        }\r\n    }\r\n\r\n    function decimals(Asset calldata asset, uint8 nativeDecimals) external view returns (uint8) {\r\n        if (asset.tokenType == TokenType.ERC1155) {\r\n            return 0;\r\n        } else if (asset.tokenType == TokenType.ERC20) {\r\n            IERC20 token = IERC20(asset.contractAddress);\r\n            return token.safeDecimals();\r\n        } else {\r\n            return nativeDecimals;\r\n        }\r\n    }\r\n\r\n    function uri(\r\n        Asset calldata asset,\r\n        NativeToken calldata nativeToken,\r\n        uint256 totalSupply,\r\n        address owner\r\n    ) external view returns (string memory) {\r\n        AssetDetails memory details;\r\n        if (asset.tokenType == TokenType.ERC1155) {\r\n            // Contracts can't retrieve URIs, so the details are out of reach\r\n            details.tokenType = \"ERC1155\";\r\n            details.name = string(\r\n                abi.encodePacked(\"ERC1155:\", uint256(uint160(asset.contractAddress)).toHexString(20), \"/\", asset.tokenId.toString())\r\n            );\r\n            details.symbol = \"ERC1155\";\r\n        } else if (asset.tokenType == TokenType.ERC20) {\r\n            IERC20 token = IERC20(asset.contractAddress);\r\n            details = AssetDetails(\"ERC20\", token.safeName(), token.safeSymbol(), token.safeDecimals());\r\n        } else {\r\n            // Native\r\n            details.tokenType = \"Native\";\r\n            details.name = nativeToken.name;\r\n            details.symbol = nativeToken.symbol;\r\n            details.decimals = nativeToken.decimals;\r\n        }\r\n\r\n        string memory properties = string(\r\n            asset.tokenType != TokenType.Native\r\n                ? abi.encodePacked(',\"tokenAddress\":\"', uint256(uint160(asset.contractAddress)).toHexString(20), '\"')\r\n                : abi.encodePacked(',\"totalSupply\":', totalSupply.toString(), ',\"fixedSupply\":', owner == address(0) ? \"true\" : \"false\")\r\n        );\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    \"data:application/json;base64,\",\r\n                    abi\r\n                        .encodePacked(\r\n                            '{\"name\":\"',\r\n                            details.name,\r\n                            '\",\"symbol\":\"',\r\n                            details.symbol,\r\n                            '\"',\r\n                            asset.tokenType == TokenType.ERC1155 ? \"\" : ',\"decimals\":',\r\n                            asset.tokenType == TokenType.ERC1155 ? \"\" : details.decimals.toString(),\r\n                            ',\"properties\":{\"strategy\":\"',\r\n                            uint256(uint160(address(asset.strategy))).toHexString(20),\r\n                            '\",\"tokenType\":\"',\r\n                            details.tokenType,\r\n                            '\"',\r\n                            properties,\r\n                            asset.tokenType == TokenType.ERC1155 ? string(abi.encodePacked(',\"tokenId\":', asset.tokenId.toString())) : \"\",\r\n                            \"}}\"\r\n                        )\r\n                        .encode()\r\n                )\r\n            );\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}